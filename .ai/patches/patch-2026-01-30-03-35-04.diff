diff --git a/tools/engine/src/engine.c b/tools/engine/src/engine.c
index 136ffa0..a200814 100644
--- a/tools/engine/src/engine.c
+++ b/tools/engine/src/engine.c
@@ -69,6 +69,12 @@ static shoots_error_code_t shoots_invariant_violation(shoots_engine_t *engine,
   return SHOOTS_ERR_INVALID_STATE;
 }
 
+shoots_error_code_t shoots_invariant_violation_internal(shoots_engine_t *engine,
+                                                        const char *message,
+                                                        shoots_error_info_t *out_error) {
+  return shoots_invariant_violation(engine, message, out_error);
+}
+
 static void shoots_assert_invariants(const shoots_engine_t *engine) {
 #ifndef NDEBUG
   if (engine == NULL) {
@@ -1128,6 +1134,18 @@ static uint64_t shoots_provider_registry_digest(const shoots_engine_t *engine) {
   return hash;
 }
 
+static void shoots_provider_maybe_seal(shoots_engine_t *engine) {
+  if (engine == NULL) {
+    return;
+  }
+  if (engine->provider_system_sealed) {
+    return;
+  }
+  if (engine->providers_locked && engine->provider_snapshot_exported) {
+    engine->provider_system_sealed = 1;
+  }
+}
+
 static int shoots_provider_request_record_compare(const void *left, const void *right) {
   const shoots_provider_request_record_t *first =
       *(const shoots_provider_request_record_t *const *)left;
@@ -1956,6 +1974,8 @@ shoots_error_code_t shoots_engine_create(const shoots_config_t *config,
   engine->provider_runtime = NULL;
   engine->provider_count = 0;
   engine->providers_locked = 0;
+  engine->provider_snapshot_exported = 0;
+  engine->provider_system_sealed = 0;
   engine->models_head = NULL;
   engine->models_tail = NULL;
   engine->sessions_head = NULL;
@@ -2717,6 +2737,8 @@ shoots_error_code_t shoots_provider_snapshot_export_internal(
   if (engine_status != SHOOTS_OK) {
     return engine_status;
   }
+  engine->provider_snapshot_exported = 1;
+  shoots_provider_maybe_seal(engine);
   uint64_t registry_digest = shoots_provider_registry_digest(engine);
 
   size_t request_count = 0;
@@ -3057,6 +3079,29 @@ shoots_error_code_t shoots_provider_snapshot_export_internal(
   return SHOOTS_OK;
 }
 
+uint8_t shoots_engine_provider_ready(const shoots_engine_t *engine) {
+  if (engine == NULL) {
+    return 0;
+  }
+  if (engine->state != SHOOTS_ENGINE_STATE_INITIALIZED) {
+    return 0;
+  }
+  if (!engine->providers_locked || !engine->provider_system_sealed) {
+    return 0;
+  }
+  if (engine->provider_count == 0) {
+    return 0;
+  }
+  shoots_provider_request_record_t *cursor = engine->provider_requests_head;
+  while (cursor != NULL) {
+    if (!cursor->received) {
+      return 0;
+    }
+    cursor = cursor->next;
+  }
+  return 1;
+}
+
 shoots_error_code_t shoots_command_append_internal(
   shoots_engine_t *engine,
   shoots_session_t *session,
diff --git a/tools/engine/src/engine_internal.h b/tools/engine/src/engine_internal.h
index dd92981..f0cb16e 100644
--- a/tools/engine/src/engine_internal.h
+++ b/tools/engine/src/engine_internal.h
@@ -277,6 +277,8 @@ struct shoots_engine {
   shoots_provider_descriptor_t providers[SHOOTS_ENGINE_MAX_PROVIDERS];
   size_t provider_count;
   uint8_t providers_locked;
+  uint8_t provider_snapshot_exported;
+  uint8_t provider_system_sealed;
 
   struct shoots_model   *models_head;
   struct shoots_model   *models_tail;
@@ -452,12 +454,19 @@ shoots_error_code_t shoots_ledger_query_substring_internal(
   size_t *out_count,
   shoots_error_info_t *out_error);
 
+shoots_error_code_t shoots_invariant_violation_internal(
+  shoots_engine_t *engine,
+  const char *message,
+  shoots_error_info_t *out_error);
+
 shoots_error_code_t shoots_provider_snapshot_export_internal(
   shoots_engine_t *engine,
   char **out_snapshot,
   size_t *out_length,
   shoots_error_info_t *out_error);
 
+uint8_t shoots_engine_provider_ready(const shoots_engine_t *engine);
+
 shoots_error_code_t shoots_command_append_internal(
   shoots_engine_t *engine,
   shoots_session_t *session,
diff --git a/tools/engine/src/provider_runtime.c b/tools/engine/src/provider_runtime.c
index c71be89..568fe38 100644
--- a/tools/engine/src/provider_runtime.c
+++ b/tools/engine/src/provider_runtime.c
@@ -111,6 +111,23 @@ static void shoots_provider_format_id_value(const char *provider_id,
   }
 }
 
+static int shoots_provider_terminal_seen(const shoots_engine_t *engine) {
+  if (engine == NULL) {
+    return 0;
+  }
+  const char *prefix = "provider_terminal ";
+  size_t prefix_len = strlen(prefix);
+  shoots_ledger_entry_t *cursor = engine->ledger_head;
+  while (cursor != NULL) {
+    if (cursor->payload != NULL &&
+        strncmp(cursor->payload, prefix, prefix_len) == 0) {
+      return 1;
+    }
+    cursor = cursor->next;
+  }
+  return 0;
+}
+
 static int shoots_provider_request_compare(const void *left, const void *right) {
   const shoots_provider_request_t *first =
       (const shoots_provider_request_t *)left;
@@ -634,6 +651,18 @@ shoots_error_code_t shoots_provider_register_internal(
   }
   char provider_id[SHOOTS_PROVIDER_ID_MAX];
   shoots_provider_format_id(descriptor, provider_id, sizeof(provider_id));
+  if (engine->provider_system_sealed) {
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                     "provider system sealed");
+    shoots_provider_emit_register_entry(engine, provider_id, "REJECT", "sealed", NULL);
+    return SHOOTS_ERR_INVALID_STATE;
+  }
+  if (shoots_provider_terminal_seen(engine)) {
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                     "provider lifecycle sealed");
+    shoots_provider_emit_register_entry(engine, provider_id, "REJECT", "terminal_guard", NULL);
+    return SHOOTS_ERR_INVALID_STATE;
+  }
   shoots_error_code_t validation_status =
       shoots_provider_descriptor_validate(descriptor, out_error);
   if (validation_status != SHOOTS_OK) {
@@ -686,6 +715,18 @@ shoots_error_code_t shoots_provider_registry_lock_internal(
                      "engine is null");
     return SHOOTS_ERR_INVALID_ARGUMENT;
   }
+  if (engine->provider_system_sealed) {
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                     "provider system sealed");
+    shoots_provider_emit_lock_entry(engine, "REJECT", NULL);
+    return SHOOTS_ERR_INVALID_STATE;
+  }
+  if (shoots_provider_terminal_seen(engine)) {
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                     "provider lifecycle sealed");
+    shoots_provider_emit_lock_entry(engine, "REJECT", NULL);
+    return SHOOTS_ERR_INVALID_STATE;
+  }
   if (engine->providers_locked) {
     shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
                      "provider registry already locked");
@@ -693,6 +734,9 @@ shoots_error_code_t shoots_provider_registry_lock_internal(
     return SHOOTS_ERR_INVALID_STATE;
   }
   engine->providers_locked = 1;
+  if (engine->provider_snapshot_exported) {
+    engine->provider_system_sealed = 1;
+  }
   return shoots_provider_emit_lock_entry(engine, "ACCEPT", out_error);
 }
 
@@ -709,6 +753,19 @@ shoots_error_code_t shoots_provider_unregister_internal(
   char provider_id_value[SHOOTS_PROVIDER_ID_MAX];
   shoots_provider_format_id_value(provider_id, provider_id_value,
                                   sizeof(provider_id_value));
+  if (engine->provider_system_sealed) {
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                     "provider system sealed");
+    shoots_provider_emit_unregister_entry(engine, provider_id_value, "REJECT", "sealed", NULL);
+    return SHOOTS_ERR_INVALID_STATE;
+  }
+  if (shoots_provider_terminal_seen(engine)) {
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                     "provider lifecycle sealed");
+    shoots_provider_emit_unregister_entry(engine, provider_id_value, "REJECT",
+                                          "terminal_guard", NULL);
+    return SHOOTS_ERR_INVALID_STATE;
+  }
   if (engine->providers_locked) {
     shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
                      "provider registry locked");
diff --git a/tools/engine/src/selfcheck.c b/tools/engine/src/selfcheck.c
index eb144a4..39691e2 100644
--- a/tools/engine/src/selfcheck.c
+++ b/tools/engine/src/selfcheck.c
@@ -1,8 +1,8 @@
 #include "engine_internal.h"
 
+#include <string.h>
 #ifndef NDEBUG
 #include <assert.h>
-#include <string.h>
 #endif
 
 static uint64_t selfcheck_hash_tool_descriptor(
@@ -67,11 +67,11 @@ static int selfcheck_reason_code_valid(const char *code_text) {
 }
 
 void selfcheck_run(shoots_engine_t *engine) {
-#ifndef NDEBUG
   if (engine == NULL) {
     return;
   }
 
+#ifndef NDEBUG
   shoots_tool_record_t *tool_cursor = engine->tools_head;
   while (tool_cursor != NULL) {
     assert(tool_cursor->tool_id != NULL);
@@ -193,6 +193,24 @@ void selfcheck_run(shoots_engine_t *engine) {
     }
     provider_request = provider_request->next;
   }
+  int terminal_seen = 0;
+  shoots_ledger_entry_t *ledger_guard = engine->ledger_head;
+  while (ledger_guard != NULL) {
+    if (ledger_guard->payload != NULL &&
+        strncmp(ledger_guard->payload, "provider_terminal ", strlen("provider_terminal ")) == 0) {
+      terminal_seen = 1;
+    } else if (terminal_seen && ledger_guard->payload != NULL) {
+      if (strncmp(ledger_guard->payload, "provider_register ",
+                  strlen("provider_register ")) == 0 ||
+          strncmp(ledger_guard->payload, "provider_unregister ",
+                  strlen("provider_unregister ")) == 0 ||
+          strncmp(ledger_guard->payload, "provider_lock ",
+                  strlen("provider_lock ")) == 0) {
+        assert(0 && "provider drift guard violated");
+      }
+    }
+    ledger_guard = ledger_guard->next;
+  }
 
   shoots_command_record_t *command = engine->commands_head;
   while (command != NULL) {
@@ -294,7 +312,40 @@ void selfcheck_run(shoots_engine_t *engine) {
     }
     ledger = ledger->next;
   }
+#endif
+  char *snapshot_first = NULL;
+  char *snapshot_second = NULL;
+  size_t snapshot_first_len = 0;
+  size_t snapshot_second_len = 0;
+  shoots_error_info_t snapshot_error;
+  shoots_error_code_t first_status =
+      shoots_provider_snapshot_export_internal(engine, &snapshot_first,
+                                                &snapshot_first_len,
+                                                &snapshot_error);
+  shoots_error_code_t second_status =
+      shoots_provider_snapshot_export_internal(engine, &snapshot_second,
+                                                &snapshot_second_len,
+                                                &snapshot_error);
+#ifndef NDEBUG
+  assert(first_status == SHOOTS_OK);
+  assert(second_status == SHOOTS_OK);
+  assert(snapshot_first_len == snapshot_second_len);
+  if (snapshot_first_len > 0) {
+    assert(memcmp(snapshot_first, snapshot_second, snapshot_first_len) == 0);
+  }
 #else
-  (void)engine;
+  if (first_status != SHOOTS_OK || second_status != SHOOTS_OK ||
+      snapshot_first_len != snapshot_second_len ||
+      (snapshot_first_len > 0 &&
+       memcmp(snapshot_first, snapshot_second, snapshot_first_len) != 0)) {
+    shoots_invariant_violation_internal(engine, "provider snapshot unstable",
+                                        &snapshot_error);
+  }
 #endif
+  if (snapshot_first != NULL) {
+    shoots_engine_alloc_free_internal(engine, snapshot_first);
+  }
+  if (snapshot_second != NULL) {
+    shoots_engine_alloc_free_internal(engine, snapshot_second);
+  }
 }
