diff --git a/.ai/patches/patch-2026-01-29-20-56-36.diff b/.ai/patches/patch-2026-01-29-20-56-36.diff
deleted file mode 100644
index acf5f7f..0000000
--- a/.ai/patches/patch-2026-01-29-20-56-36.diff
+++ /dev/null
@@ -1,37 +0,0 @@
-diff --git a/tools/engine/src/provider_runtime.c b/tools/engine/src/provider_runtime.c
-index 3d7ae9c..e19b1ed 100644
---- a/tools/engine/src/provider_runtime.c
-+++ b/tools/engine/src/provider_runtime.c
-@@ -178,9 +178,11 @@ shoots_error_code_t shoots_provider_descriptor_validate(
-                      "provider_id length invalid");
-     return SHOOTS_ERR_INVALID_ARGUMENT;
-   }
--  if (descriptor->provider_id[descriptor->provider_id_len] != '\0') {
-+  size_t provider_id_len =
-+      strnlen(descriptor->provider_id, SHOOTS_PROVIDER_ID_MAX);
-+  if (provider_id_len != descriptor->provider_id_len) {
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
--                     "provider_id not terminated");
-+                     "provider_id length mismatch");
-     return SHOOTS_ERR_INVALID_ARGUMENT;
-   }
-   for (uint8_t index = 0; index < descriptor->provider_id_len; index++) {
-@@ -190,6 +192,18 @@ shoots_error_code_t shoots_provider_descriptor_validate(
-       return SHOOTS_ERR_INVALID_ARGUMENT;
-     }
-   }
-+  if (descriptor->provider_id[descriptor->provider_id_len] != '\0') {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "provider_id not terminated");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  for (size_t index = provider_id_len + 1; index < SHOOTS_PROVIDER_ID_MAX; index++) {
-+    if (descriptor->provider_id[index] != '\0') {
-+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                       "provider_id padding invalid");
-+      return SHOOTS_ERR_INVALID_ARGUMENT;
-+    }
-+  }
-   if (descriptor->supported_tool_categories == 0 ||
-       (descriptor->supported_tool_categories & ~SHOOTS_PROVIDER_TOOL_CATEGORY_MASK) != 0) {
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
diff --git a/.ai/patches/patch-2026-01-29-21-06-11.diff b/.ai/patches/patch-2026-01-29-21-06-11.diff
deleted file mode 100644
index 64a7400..0000000
--- a/.ai/patches/patch-2026-01-29-21-06-11.diff
+++ /dev/null
@@ -1,241 +0,0 @@
-diff --git a/tools/engine/src/engine.c b/tools/engine/src/engine.c
-index 547f0da..ad85038 100644
---- a/tools/engine/src/engine.c
-+++ b/tools/engine/src/engine.c
-@@ -187,6 +187,8 @@ static void shoots_assert_invariants(const shoots_engine_t *engine) {
-     }
-   }
-   assert(engine->tools_locked <= 1);
-+  assert(engine->provider_count <= SHOOTS_ENGINE_MAX_PROVIDERS);
-+  assert(engine->providers_locked <= 1);
-   if (engine->results_head == NULL) {
-     assert(engine->results_tail == NULL);
-   } else {
-@@ -1306,6 +1308,8 @@ shoots_error_code_t shoots_engine_create(const shoots_config_t *config,
-   engine->magic = SHOOTS_ENGINE_MAGIC;
-   engine->allocations_head = NULL;
-   engine->provider_runtime = NULL;
-+  engine->provider_count = 0;
-+  engine->providers_locked = 0;
-   engine->models_head = NULL;
-   engine->models_tail = NULL;
-   engine->sessions_head = NULL;
-@@ -1351,6 +1355,7 @@ shoots_error_code_t shoots_engine_create(const shoots_config_t *config,
-     return runtime_status;
-   }
- 
-+  engine->providers_locked = 1;
-   engine->tools_locked = 1;
- 
-   *out_engine = engine;
-@@ -1410,6 +1415,8 @@ shoots_error_code_t shoots_engine_destroy(shoots_engine_t *engine,
-   engine->tools_head = NULL;
-   engine->tools_tail = NULL;
-   engine->tools_locked = 0;
-+  engine->provider_count = 0;
-+  engine->providers_locked = 0;
-   engine->results_head = NULL;
-   engine->results_tail = NULL;
-   engine->commands_head = NULL;
-diff --git a/tools/engine/src/engine_internal.h b/tools/engine/src/engine_internal.h
-index a06cb09..32de924 100644
---- a/tools/engine/src/engine_internal.h
-+++ b/tools/engine/src/engine_internal.h
-@@ -178,6 +178,7 @@ typedef struct shoots_result_record {
- 
- #define SHOOTS_SESSION_MAX_PLANS 4u
- #define SHOOTS_SESSION_PLAN_MAX_TOOLS 64u
-+#define SHOOTS_ENGINE_MAX_PROVIDERS 8u
- 
- typedef struct shoots_plan_record {
-   uint64_t plan_id;
-@@ -255,6 +256,9 @@ struct shoots_engine {
-   void   *allocations_head;
- 
-   shoots_provider_runtime_t *provider_runtime;
-+  shoots_provider_descriptor_t providers[SHOOTS_ENGINE_MAX_PROVIDERS];
-+  size_t provider_count;
-+  uint8_t providers_locked;
- 
-   struct shoots_model   *models_head;
-   struct shoots_model   *models_tail;
-@@ -303,6 +307,11 @@ void shoots_engine_alloc_free_internal(
-   shoots_engine_t *engine,
-   void *buffer);
- 
-+shoots_error_code_t shoots_provider_register_internal(
-+  shoots_engine_t *engine,
-+  const shoots_provider_descriptor_t *descriptor,
-+  shoots_error_info_t *out_error);
-+
- shoots_error_code_t shoots_session_create_internal(
-   shoots_engine_t *engine,
-   const char *intent_id,
-diff --git a/tools/engine/src/provider_runtime.c b/tools/engine/src/provider_runtime.c
-index e19b1ed..02a5f82 100644
---- a/tools/engine/src/provider_runtime.c
-+++ b/tools/engine/src/provider_runtime.c
-@@ -1,5 +1,6 @@
- #include "engine_internal.h"
- 
-+#include <stdio.h>
- #include <string.h>
- #ifndef NDEBUG
- #include <assert.h>
-@@ -57,6 +58,97 @@ static void shoots_error_set(shoots_error_info_t *out_error,
-   out_error->message = message;
- }
- 
-+static void shoots_provider_format_id(const shoots_provider_descriptor_t *descriptor,
-+                                      char *buffer,
-+                                      size_t buffer_len) {
-+  if (buffer == NULL || buffer_len == 0) {
-+    return;
-+  }
-+  if (descriptor == NULL) {
-+    strncpy(buffer, "(null)", buffer_len);
-+    buffer[buffer_len - 1] = '\0';
-+    return;
-+  }
-+  size_t length = 0;
-+  for (; length + 1 < buffer_len && length < SHOOTS_PROVIDER_ID_MAX; length++) {
-+    char value = descriptor->provider_id[length];
-+    if (value == '\0') {
-+      break;
-+    }
-+    buffer[length] = value;
-+  }
-+  buffer[length] = '\0';
-+  if (length == 0) {
-+    strncpy(buffer, "(empty)", buffer_len);
-+    buffer[buffer_len - 1] = '\0';
-+  }
-+}
-+
-+static shoots_error_code_t shoots_provider_emit_register_entry(
-+  shoots_engine_t *engine,
-+  const char *provider_id,
-+  const char *status,
-+  const char *reason,
-+  shoots_error_info_t *out_error) {
-+  const char *safe_provider_id = provider_id != NULL ? provider_id : "(null)";
-+  const char *safe_status = status != NULL ? status : "UNKNOWN";
-+  const char *safe_reason = reason != NULL ? reason : "";
-+  const char *reason_format = reason != NULL && reason[0] != '\0'
-+                                  ? " reason=%s"
-+                                  : "%s";
-+  int required = snprintf(NULL, 0,
-+                          "provider_register provider_id=%s status=%s",
-+                          safe_provider_id, safe_status);
-+  if (required < 0) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  int reason_required = snprintf(NULL, 0, reason_format, safe_reason);
-+  if (reason_required < 0) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  size_t payload_len = (size_t)required + (size_t)reason_required;
-+  if (payload_len > SHOOTS_LEDGER_MAX_BYTES) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger payload too large");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  char *payload = (char *)shoots_engine_alloc_internal(
-+      engine, payload_len + 1, out_error);
-+  if (payload == NULL) {
-+    return SHOOTS_ERR_OUT_OF_MEMORY;
-+  }
-+  int written = snprintf(payload, payload_len + 1,
-+                         "provider_register provider_id=%s status=%s",
-+                         safe_provider_id, safe_status);
-+  if (written < 0) {
-+    shoots_engine_alloc_free_internal(engine, payload);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  if (reason_required > 0 && reason != NULL && reason[0] != '\0') {
-+    int reason_written = snprintf(payload + written,
-+                                  payload_len + 1 - (size_t)written,
-+                                  " reason=%s",
-+                                  safe_reason);
-+    if (reason_written < 0) {
-+      shoots_engine_alloc_free_internal(engine, payload);
-+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                       "ledger format failed");
-+      return SHOOTS_ERR_INVALID_STATE;
-+    }
-+  }
-+  shoots_ledger_entry_t *entry = NULL;
-+  shoots_error_code_t status_code = shoots_ledger_append_internal(
-+      engine, SHOOTS_LEDGER_ENTRY_DECISION, payload, &entry, out_error);
-+  shoots_engine_alloc_free_internal(engine, payload);
-+  return status_code;
-+}
-+
- shoots_error_code_t shoots_provider_runtime_create(
-   shoots_engine_t *engine,
-   const shoots_config_t *config,
-@@ -223,3 +315,58 @@ shoots_error_code_t shoots_provider_descriptor_validate(
-   }
-   return SHOOTS_OK;
- }
-+
-+shoots_error_code_t shoots_provider_register_internal(
-+  shoots_engine_t *engine,
-+  const shoots_provider_descriptor_t *descriptor,
-+  shoots_error_info_t *out_error) {
-+  shoots_error_clear(out_error);
-+  if (engine == NULL) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "engine is null");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  char provider_id[SHOOTS_PROVIDER_ID_MAX];
-+  shoots_provider_format_id(descriptor, provider_id, sizeof(provider_id));
-+  shoots_error_code_t validation_status =
-+      shoots_provider_descriptor_validate(descriptor, out_error);
-+  if (validation_status != SHOOTS_OK) {
-+    shoots_provider_emit_register_entry(engine, provider_id, "REJECT",
-+                                        "invalid_descriptor", NULL);
-+    return validation_status;
-+  }
-+  if (engine->providers_locked) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "provider registry locked");
-+    shoots_provider_emit_register_entry(engine, provider_id, "REJECT", "locked", NULL);
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  if (engine->provider_count >= SHOOTS_ENGINE_MAX_PROVIDERS) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "provider registry full");
-+    shoots_provider_emit_register_entry(engine, provider_id, "REJECT",
-+                                        "registry_full", NULL);
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  for (size_t index = 0; index < engine->provider_count; index++) {
-+    const shoots_provider_descriptor_t *existing = &engine->providers[index];
-+    if (existing->provider_id_len == descriptor->provider_id_len &&
-+        memcmp(existing->provider_id, descriptor->provider_id,
-+               descriptor->provider_id_len) == 0) {
-+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT,
-+                       SHOOTS_SEVERITY_RECOVERABLE, "provider_id exists");
-+      shoots_provider_emit_register_entry(engine, provider_id, "REJECT",
-+                                          "provider_exists", NULL);
-+      return SHOOTS_ERR_INVALID_ARGUMENT;
-+    }
-+  }
-+  engine->providers[engine->provider_count] = *descriptor;
-+  engine->provider_count++;
-+  shoots_error_code_t ledger_status =
-+      shoots_provider_emit_register_entry(engine, provider_id, "ACCEPT", NULL,
-+                                          out_error);
-+  if (ledger_status != SHOOTS_OK) {
-+    return ledger_status;
-+  }
-+  return SHOOTS_OK;
-+}
diff --git a/.ai/patches/patch-2026-01-29-21-09-53.diff b/.ai/patches/patch-2026-01-29-21-09-53.diff
deleted file mode 100644
index 1d51b44..0000000
--- a/.ai/patches/patch-2026-01-29-21-09-53.diff
+++ /dev/null
@@ -1,12 +0,0 @@
-diff --git a/tools/engine/src/engine.c b/tools/engine/src/engine.c
-index ad85038..fd904d2 100644
---- a/tools/engine/src/engine.c
-+++ b/tools/engine/src/engine.c
-@@ -1355,7 +1355,6 @@ shoots_error_code_t shoots_engine_create(const shoots_config_t *config,
-     return runtime_status;
-   }
- 
--  engine->providers_locked = 1;
-   engine->tools_locked = 1;
- 
-   *out_engine = engine;
diff --git a/.ai/patches/patch-2026-01-29-21-13-44.diff b/.ai/patches/patch-2026-01-29-21-13-44.diff
deleted file mode 100644
index 2c87190..0000000
--- a/.ai/patches/patch-2026-01-29-21-13-44.diff
+++ /dev/null
@@ -1,89 +0,0 @@
-diff --git a/tools/engine/src/engine_internal.h b/tools/engine/src/engine_internal.h
-index 32de924..113eb71 100644
---- a/tools/engine/src/engine_internal.h
-+++ b/tools/engine/src/engine_internal.h
-@@ -312,6 +312,10 @@ shoots_error_code_t shoots_provider_register_internal(
-   const shoots_provider_descriptor_t *descriptor,
-   shoots_error_info_t *out_error);
- 
-+shoots_error_code_t shoots_provider_registry_lock_internal(
-+  shoots_engine_t *engine,
-+  shoots_error_info_t *out_error);
-+
- shoots_error_code_t shoots_session_create_internal(
-   shoots_engine_t *engine,
-   const char *intent_id,
-diff --git a/tools/engine/src/provider_runtime.c b/tools/engine/src/provider_runtime.c
-index 02a5f82..2313a25 100644
---- a/tools/engine/src/provider_runtime.c
-+++ b/tools/engine/src/provider_runtime.c
-@@ -149,6 +149,46 @@ static shoots_error_code_t shoots_provider_emit_register_entry(
-   return status_code;
- }
- 
-+static shoots_error_code_t shoots_provider_emit_lock_entry(
-+  shoots_engine_t *engine,
-+  const char *status,
-+  shoots_error_info_t *out_error) {
-+  const char *safe_status = status != NULL ? status : "UNKNOWN";
-+  int required = snprintf(NULL, 0,
-+                          "provider_lock status=%s",
-+                          safe_status);
-+  if (required < 0) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  size_t payload_len = (size_t)required;
-+  if (payload_len > SHOOTS_LEDGER_MAX_BYTES) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger payload too large");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  char *payload = (char *)shoots_engine_alloc_internal(
-+      engine, payload_len + 1, out_error);
-+  if (payload == NULL) {
-+    return SHOOTS_ERR_OUT_OF_MEMORY;
-+  }
-+  int written = snprintf(payload, payload_len + 1,
-+                         "provider_lock status=%s",
-+                         safe_status);
-+  if (written < 0) {
-+    shoots_engine_alloc_free_internal(engine, payload);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  shoots_ledger_entry_t *entry = NULL;
-+  shoots_error_code_t status_code = shoots_ledger_append_internal(
-+      engine, SHOOTS_LEDGER_ENTRY_DECISION, payload, &entry, out_error);
-+  shoots_engine_alloc_free_internal(engine, payload);
-+  return status_code;
-+}
-+
- shoots_error_code_t shoots_provider_runtime_create(
-   shoots_engine_t *engine,
-   const shoots_config_t *config,
-@@ -370,3 +410,22 @@ shoots_error_code_t shoots_provider_register_internal(
-   }
-   return SHOOTS_OK;
- }
-+
-+shoots_error_code_t shoots_provider_registry_lock_internal(
-+  shoots_engine_t *engine,
-+  shoots_error_info_t *out_error) {
-+  shoots_error_clear(out_error);
-+  if (engine == NULL) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "engine is null");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  if (engine->providers_locked) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "provider registry already locked");
-+    shoots_provider_emit_lock_entry(engine, "REJECT", NULL);
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  engine->providers_locked = 1;
-+  return shoots_provider_emit_lock_entry(engine, "ACCEPT", out_error);
-+}
diff --git a/.ai/patches/patch-2026-01-30-01-23-04.diff b/.ai/patches/patch-2026-01-30-01-23-04.diff
deleted file mode 100644
index da16b22..0000000
--- a/.ai/patches/patch-2026-01-30-01-23-04.diff
+++ /dev/null
@@ -1,1509 +0,0 @@
-diff --git a/.ai/patches/patch-2026-01-30-01-14-00.diff b/.ai/patches/patch-2026-01-30-01-14-00.diff
-deleted file mode 100644
-index f348c6f..0000000
---- a/.ai/patches/patch-2026-01-30-01-14-00.diff
-+++ /dev/null
-@@ -1,697 +0,0 @@
--diff --git a/.ai/patches/patch-2026-01-30-01-04-36.diff b/.ai/patches/patch-2026-01-30-01-04-36.diff
--deleted file mode 100644
--index ed48b41..0000000
----- a/.ai/patches/patch-2026-01-30-01-04-36.diff
--+++ /dev/null
--@@ -1,195 +0,0 @@
---diff --git a/tools/engine/src/engine_internal.h b/tools/engine/src/engine_internal.h
---index 113eb71..da07536 100644
------ a/tools/engine/src/engine_internal.h
---+++ b/tools/engine/src/engine_internal.h
---@@ -316,6 +316,11 @@ shoots_error_code_t shoots_provider_registry_lock_internal(
---   shoots_engine_t *engine,
---   shoots_error_info_t *out_error);
--- 
---+shoots_error_code_t shoots_provider_unregister_internal(
---+  shoots_engine_t *engine,
---+  const char *provider_id,
---+  shoots_error_info_t *out_error);
---+
--- shoots_error_code_t shoots_session_create_internal(
---   shoots_engine_t *engine,
---   const char *intent_id,
---diff --git a/tools/engine/src/provider_runtime.c b/tools/engine/src/provider_runtime.c
---index 2313a25..083c67c 100644
------ a/tools/engine/src/provider_runtime.c
---+++ b/tools/engine/src/provider_runtime.c
---@@ -84,6 +84,32 @@ static void shoots_provider_format_id(const shoots_provider_descriptor_t *descri
---   }
--- }
--- 
---+static void shoots_provider_format_id_value(const char *provider_id,
---+                                            char *buffer,
---+                                            size_t buffer_len) {
---+  if (buffer == NULL || buffer_len == 0) {
---+    return;
---+  }
---+  if (provider_id == NULL) {
---+    strncpy(buffer, "(null)", buffer_len);
---+    buffer[buffer_len - 1] = '\0';
---+    return;
---+  }
---+  size_t length = 0;
---+  for (; length + 1 < buffer_len && length < SHOOTS_PROVIDER_ID_MAX; length++) {
---+    char value = provider_id[length];
---+    if (value == '\0') {
---+      break;
---+    }
---+    buffer[length] = value;
---+  }
---+  buffer[length] = '\0';
---+  if (length == 0) {
---+    strncpy(buffer, "(empty)", buffer_len);
---+    buffer[buffer_len - 1] = '\0';
---+  }
---+}
---+
--- static shoots_error_code_t shoots_provider_emit_register_entry(
---   shoots_engine_t *engine,
---   const char *provider_id,
---@@ -149,6 +175,71 @@ static shoots_error_code_t shoots_provider_emit_register_entry(
---   return status_code;
--- }
--- 
---+static shoots_error_code_t shoots_provider_emit_unregister_entry(
---+  shoots_engine_t *engine,
---+  const char *provider_id,
---+  const char *status,
---+  const char *reason,
---+  shoots_error_info_t *out_error) {
---+  const char *safe_provider_id = provider_id != NULL ? provider_id : "(null)";
---+  const char *safe_status = status != NULL ? status : "UNKNOWN";
---+  const char *safe_reason = reason != NULL ? reason : "";
---+  const char *reason_format = reason != NULL && reason[0] != '\0'
---+                                  ? " reason=%s"
---+                                  : "%s";
---+  int required = snprintf(NULL, 0,
---+                          "provider_unregister provider_id=%s status=%s",
---+                          safe_provider_id, safe_status);
---+  if (required < 0) {
---+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
---+                     "ledger format failed");
---+    return SHOOTS_ERR_INVALID_STATE;
---+  }
---+  int reason_required = snprintf(NULL, 0, reason_format, safe_reason);
---+  if (reason_required < 0) {
---+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
---+                     "ledger format failed");
---+    return SHOOTS_ERR_INVALID_STATE;
---+  }
---+  size_t payload_len = (size_t)required + (size_t)reason_required;
---+  if (payload_len > SHOOTS_LEDGER_MAX_BYTES) {
---+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
---+                     "ledger payload too large");
---+    return SHOOTS_ERR_INVALID_ARGUMENT;
---+  }
---+  char *payload = (char *)shoots_engine_alloc_internal(
---+      engine, payload_len + 1, out_error);
---+  if (payload == NULL) {
---+    return SHOOTS_ERR_OUT_OF_MEMORY;
---+  }
---+  int written = snprintf(payload, payload_len + 1,
---+                         "provider_unregister provider_id=%s status=%s",
---+                         safe_provider_id, safe_status);
---+  if (written < 0) {
---+    shoots_engine_alloc_free_internal(engine, payload);
---+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
---+                     "ledger format failed");
---+    return SHOOTS_ERR_INVALID_STATE;
---+  }
---+  if (reason_required > 0 && reason != NULL && reason[0] != '\0') {
---+    int reason_written = snprintf(payload + written,
---+                                  payload_len + 1 - (size_t)written,
---+                                  " reason=%s",
---+                                  safe_reason);
---+    if (reason_written < 0) {
---+      shoots_engine_alloc_free_internal(engine, payload);
---+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
---+                       "ledger format failed");
---+      return SHOOTS_ERR_INVALID_STATE;
---+    }
---+  }
---+  shoots_ledger_entry_t *entry = NULL;
---+  shoots_error_code_t status_code = shoots_ledger_append_internal(
---+      engine, SHOOTS_LEDGER_ENTRY_DECISION, payload, &entry, out_error);
---+  shoots_engine_alloc_free_internal(engine, payload);
---+  return status_code;
---+}
---+
--- static shoots_error_code_t shoots_provider_emit_lock_entry(
---   shoots_engine_t *engine,
---   const char *status,
---@@ -429,3 +520,69 @@ shoots_error_code_t shoots_provider_registry_lock_internal(
---   engine->providers_locked = 1;
---   return shoots_provider_emit_lock_entry(engine, "ACCEPT", out_error);
--- }
---+
---+shoots_error_code_t shoots_provider_unregister_internal(
---+  shoots_engine_t *engine,
---+  const char *provider_id,
---+  shoots_error_info_t *out_error) {
---+  shoots_error_clear(out_error);
---+  if (engine == NULL) {
---+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
---+                     "engine is null");
---+    return SHOOTS_ERR_INVALID_ARGUMENT;
---+  }
---+  char provider_id_value[SHOOTS_PROVIDER_ID_MAX];
---+  shoots_provider_format_id_value(provider_id, provider_id_value,
---+                                  sizeof(provider_id_value));
---+  if (engine->providers_locked) {
---+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
---+                     "provider registry locked");
---+    shoots_provider_emit_unregister_entry(engine, provider_id_value, "REJECT",
---+                                          "locked", NULL);
---+    return SHOOTS_ERR_INVALID_STATE;
---+  }
---+  if (provider_id == NULL) {
---+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
---+                     "provider_id is null");
---+    shoots_provider_emit_unregister_entry(engine, provider_id_value, "REJECT",
---+                                          "invalid_provider_id", NULL);
---+    return SHOOTS_ERR_INVALID_ARGUMENT;
---+  }
---+  size_t provider_id_len = strnlen(provider_id, SHOOTS_PROVIDER_ID_MAX);
---+  if (provider_id_len == 0 || provider_id_len >= SHOOTS_PROVIDER_ID_MAX) {
---+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
---+                     "provider_id invalid");
---+    shoots_provider_emit_unregister_entry(engine, provider_id_value, "REJECT",
---+                                          "invalid_provider_id", NULL);
---+    return SHOOTS_ERR_INVALID_ARGUMENT;
---+  }
---+  size_t match_index = engine->provider_count;
---+  for (size_t index = 0; index < engine->provider_count; index++) {
---+    const shoots_provider_descriptor_t *existing = &engine->providers[index];
---+    if (existing->provider_id_len == provider_id_len &&
---+        memcmp(existing->provider_id, provider_id, provider_id_len) == 0) {
---+      match_index = index;
---+      break;
---+    }
---+  }
---+  if (match_index == engine->provider_count) {
---+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
---+                     "provider not found");
---+    shoots_provider_emit_unregister_entry(engine, provider_id_value, "REJECT",
---+                                          "not_found", NULL);
---+    return SHOOTS_ERR_INVALID_ARGUMENT;
---+  }
---+  for (size_t index = match_index + 1; index < engine->provider_count; index++) {
---+    engine->providers[index - 1] = engine->providers[index];
---+  }
---+  engine->provider_count--;
---+  memset(&engine->providers[engine->provider_count], 0,
---+         sizeof(engine->providers[engine->provider_count]));
---+  shoots_error_code_t ledger_status =
---+      shoots_provider_emit_unregister_entry(engine, provider_id_value, "ACCEPT",
---+                                            NULL, out_error);
---+  if (ledger_status != SHOOTS_OK) {
---+    return ledger_status;
---+  }
---+  return SHOOTS_OK;
---+}
--diff --git a/tools/engine/src/engine.c b/tools/engine/src/engine.c
--index fd904d2..b9880f2 100644
----- a/tools/engine/src/engine.c
--+++ b/tools/engine/src/engine.c
--@@ -738,6 +738,126 @@ static const char *shoots_tool_reject_code_text(shoots_tool_reject_code_t code)
--   }
-- }
-- 
--+static const shoots_plan_record_t *shoots_session_find_plan(
--+  const shoots_session_t *session,
--+  uint64_t plan_id) {
--+  if (session == NULL) {
--+    return NULL;
--+  }
--+  for (size_t index = 0; index < session->plan_count; index++) {
--+    if (session->plans[index].plan_id == plan_id) {
--+      return &session->plans[index];
--+    }
--+  }
--+  return NULL;
--+}
--+
--+static void shoots_provider_request_format_id(
--+  const shoots_provider_descriptor_t *provider,
--+  char *buffer,
--+  size_t buffer_len) {
--+  if (buffer == NULL || buffer_len == 0) {
--+    return;
--+  }
--+  if (provider == NULL) {
--+    strncpy(buffer, "(null)", buffer_len);
--+    buffer[buffer_len - 1] = '\0';
--+    return;
--+  }
--+  size_t length = 0;
--+  for (; length + 1 < buffer_len && length < SHOOTS_PROVIDER_ID_MAX; length++) {
--+    char value = provider->provider_id[length];
--+    if (value == '\0') {
--+      break;
--+    }
--+    buffer[length] = value;
--+  }
--+  buffer[length] = '\0';
--+  if (length == 0) {
--+    strncpy(buffer, "(empty)", buffer_len);
--+    buffer[buffer_len - 1] = '\0';
--+  }
--+}
--+
--+static shoots_error_code_t shoots_provider_request_append_decision(
--+  shoots_engine_t *engine,
--+  const char *provider_id,
--+  const char *tool_id,
--+  uint64_t plan_id,
--+  uint64_t execution_slot,
--+  uint64_t capability_mask,
--+  uint64_t input_hash,
--+  const char *status,
--+  const char *reason,
--+  shoots_error_info_t *out_error) {
--+  const char *safe_provider_id = provider_id != NULL ? provider_id : "(null)";
--+  const char *safe_tool_id = tool_id != NULL ? tool_id : "(null)";
--+  const char *safe_status = status != NULL ? status : "UNKNOWN";
--+  const char *safe_reason = reason != NULL ? reason : "";
--+  const char *reason_format = reason != NULL && reason[0] != '\0'
--+                                  ? " reason=%s"
--+                                  : "%s";
--+  int required = snprintf(NULL, 0,
--+                          "provider_request status=%s provider_id=%s tool_id=%s"
--+                          " plan_id=%" PRIu64 " execution_slot=%" PRIu64
--+                          " capability_mask=0x%016" PRIx64
--+                          " input_hash=0x%016" PRIx64,
--+                          safe_status, safe_provider_id, safe_tool_id,
--+                          plan_id, execution_slot, capability_mask, input_hash);
--+  if (required < 0) {
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "ledger format failed");
--+    return SHOOTS_ERR_INVALID_STATE;
--+  }
--+  int reason_required = snprintf(NULL, 0, reason_format, safe_reason);
--+  if (reason_required < 0) {
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "ledger format failed");
--+    return SHOOTS_ERR_INVALID_STATE;
--+  }
--+  size_t payload_len = (size_t)required + (size_t)reason_required;
--+  if (payload_len > SHOOTS_LEDGER_MAX_BYTES) {
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "ledger payload too large");
--+    return SHOOTS_ERR_INVALID_ARGUMENT;
--+  }
--+  char *payload = (char *)shoots_engine_alloc_internal(
--+      engine, payload_len + 1, out_error);
--+  if (payload == NULL) {
--+    return SHOOTS_ERR_OUT_OF_MEMORY;
--+  }
--+  int written = snprintf(payload, payload_len + 1,
--+                         "provider_request status=%s provider_id=%s tool_id=%s"
--+                         " plan_id=%" PRIu64 " execution_slot=%" PRIu64
--+                         " capability_mask=0x%016" PRIx64
--+                         " input_hash=0x%016" PRIx64,
--+                         safe_status, safe_provider_id, safe_tool_id,
--+                         plan_id, execution_slot, capability_mask, input_hash);
--+  if (written < 0) {
--+    shoots_engine_alloc_free_internal(engine, payload);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "ledger format failed");
--+    return SHOOTS_ERR_INVALID_STATE;
--+  }
--+  if (reason_required > 0 && reason != NULL && reason[0] != '\0') {
--+    int reason_written = snprintf(payload + written,
--+                                  payload_len + 1 - (size_t)written,
--+                                  " reason=%s",
--+                                  safe_reason);
--+    if (reason_written < 0) {
--+      shoots_engine_alloc_free_internal(engine, payload);
--+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--+                       "ledger format failed");
--+      return SHOOTS_ERR_INVALID_STATE;
--+    }
--+  }
--+  shoots_ledger_entry_t *entry = NULL;
--+  shoots_error_code_t status_code = shoots_ledger_append_internal(
--+      engine, SHOOTS_LEDGER_ENTRY_DECISION, payload, &entry, out_error);
--+  shoots_engine_alloc_free_internal(engine, payload);
--+  return status_code;
--+}
--+
-- static void shoots_tool_reject_reason_set(shoots_tool_reject_reason_t *reason,
--                                           shoots_tool_reject_code_t code,
--                                           const char *token) {
--@@ -2549,6 +2669,273 @@ shoots_error_code_t shoots_tool_invoke_internal(
--   return SHOOTS_ERR_UNSUPPORTED;
-- }
-- 
--+shoots_error_code_t shoots_provider_request_mint_internal(
--+  shoots_engine_t *engine,
--+  shoots_session_t *session,
--+  uint64_t plan_id,
--+  uint64_t execution_slot,
--+  const char *tool_id,
--+  const shoots_provider_descriptor_t *provider,
--+  uint64_t capability_mask,
--+  uint64_t input_hash,
--+  const uint8_t *arg_blob,
--+  uint32_t arg_size,
--+  shoots_provider_request_t *out_request,
--+  shoots_error_info_t *out_error) {
--+  shoots_error_clear(out_error);
--+  if (out_request == NULL) {
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "out_request is null");
--+    return SHOOTS_ERR_INVALID_ARGUMENT;
--+  }
--+  memset(out_request, 0, sizeof(*out_request));
--+  shoots_error_code_t engine_status = shoots_validate_engine(engine, out_error);
--+  if (engine_status != SHOOTS_OK) {
--+    return engine_status;
--+  }
--+  shoots_error_code_t session_status = shoots_validate_session(engine, session, out_error);
--+  if (session_status != SHOOTS_OK) {
--+    return session_status;
--+  }
--+  char provider_id_value[SHOOTS_PROVIDER_ID_MAX];
--+  shoots_provider_request_format_id(provider, provider_id_value,
--+                                    sizeof(provider_id_value));
--+  if (session->state != SHOOTS_SESSION_STATE_ACTIVE) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "session_inactive", NULL);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "session not active");
--+    return SHOOTS_ERR_INVALID_STATE;
--+  }
--+  if (plan_id == 0) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "plan_id_invalid", NULL);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "plan_id invalid");
--+    return SHOOTS_ERR_INVALID_ARGUMENT;
--+  }
--+  if (!shoots_intent_exists(engine, session->intent_id)) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "intent_missing", NULL);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "intent missing");
--+    return SHOOTS_ERR_INVALID_STATE;
--+  }
--+  if (shoots_session_find_plan(session, plan_id) == NULL) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "plan_not_found", NULL);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "plan not found");
--+    return SHOOTS_ERR_INVALID_ARGUMENT;
--+  }
--+  if (tool_id == NULL || tool_id[0] == '\0') {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "tool_id_invalid", NULL);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "tool_id is null or empty");
--+    return SHOOTS_ERR_INVALID_ARGUMENT;
--+  }
--+  size_t tool_id_len = strlen(tool_id);
--+  if (tool_id_len >= SHOOTS_PROVIDER_TOOL_ID_MAX) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "tool_id_too_long", NULL);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "tool_id too long");
--+    return SHOOTS_ERR_INVALID_ARGUMENT;
--+  }
--+  if (provider == NULL) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "provider_missing", NULL);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "provider is null");
--+    return SHOOTS_ERR_INVALID_ARGUMENT;
--+  }
--+  shoots_error_code_t provider_status =
--+      shoots_provider_descriptor_validate(provider, out_error);
--+  if (provider_status != SHOOTS_OK) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "provider_invalid", NULL);
--+    return provider_status;
--+  }
--+  const shoots_tool_record_t *tool = shoots_tool_find(engine, tool_id);
--+  if (tool == NULL) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "tool_not_found", NULL);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "tool not found");
--+    return SHOOTS_ERR_INVALID_ARGUMENT;
--+  }
--+  const shoots_provider_descriptor_t *registered_provider = NULL;
--+  for (size_t index = 0; index < engine->provider_count; index++) {
--+    const shoots_provider_descriptor_t *candidate = &engine->providers[index];
--+    if (candidate->provider_id_len == provider->provider_id_len &&
--+        memcmp(candidate->provider_id, provider->provider_id,
--+               provider->provider_id_len) == 0) {
--+      registered_provider = candidate;
--+      break;
--+    }
--+  }
--+  if (registered_provider == NULL) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "provider_not_registered", NULL);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "provider not registered");
--+    return SHOOTS_ERR_INVALID_ARGUMENT;
--+  }
--+  uint32_t required_category = 0;
--+  if (tool->category == SHOOTS_TOOL_CATEGORY_EXECUTION) {
--+    required_category = SHOOTS_PROVIDER_TOOL_CATEGORY_EXECUTION;
--+  } else if (tool->category == SHOOTS_TOOL_CATEGORY_INTEGRATION) {
--+    required_category = SHOOTS_PROVIDER_TOOL_CATEGORY_INTEGRATION;
--+  } else {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "tool_category_invalid", NULL);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "tool category invalid");
--+    return SHOOTS_ERR_INVALID_ARGUMENT;
--+  }
--+  if ((registered_provider->supported_tool_categories & required_category) == 0) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "category_mismatch", NULL);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "provider category mismatch");
--+    return SHOOTS_ERR_INVALID_ARGUMENT;
--+  }
--+  if ((tool->determinism_flags & ~registered_provider->guarantees_mask) != 0) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "guarantee_mismatch", NULL);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "provider guarantees mismatch");
--+    return SHOOTS_ERR_INVALID_ARGUMENT;
--+  }
--+  if ((capability_mask & ~tool->capabilities) != 0) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "capability_mismatch", NULL);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "capability mask invalid");
--+    return SHOOTS_ERR_INVALID_ARGUMENT;
--+  }
--+  if (arg_size > SHOOTS_PROVIDER_ARG_MAX_BYTES) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "arg_too_large", NULL);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "arg size too large");
--+    return SHOOTS_ERR_INVALID_ARGUMENT;
--+  }
--+  if (arg_size > 0 && arg_blob == NULL) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "arg_missing", NULL);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "arg blob missing");
--+    return SHOOTS_ERR_INVALID_ARGUMENT;
--+  }
--+  if (execution_slot == 0) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "execution_slot_invalid", NULL);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "execution_slot invalid");
--+    return SHOOTS_ERR_INVALID_ARGUMENT;
--+  }
--+  if (session->has_active_execution) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "execution_active", NULL);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "execution already active");
--+    return SHOOTS_ERR_INVALID_STATE;
--+  }
--+  if (session->has_terminal_execution &&
--+      execution_slot <= session->terminal_execution_slot) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "execution_slot_terminal", NULL);
--+    return shoots_invariant_violation(engine, "execution slot terminal", out_error);
--+  }
--+  if (session->next_execution_slot == 0) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "execution_slots_exhausted", NULL);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "execution slots exhausted");
--+    return SHOOTS_ERR_INVALID_STATE;
--+  }
--+  if (execution_slot != session->next_execution_slot) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "execution_slot_out_of_order", NULL);
--+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
--+                     "execution slot out of order");
--+    return SHOOTS_ERR_INVALID_ARGUMENT;
--+  }
--+  shoots_error_code_t runtime_status =
--+      shoots_provider_runtime_validate_ready(engine->provider_runtime, out_error);
--+  if (runtime_status != SHOOTS_OK) {
--+    shoots_provider_request_append_decision(
--+        engine, provider_id_value, tool_id, plan_id, execution_slot,
--+        capability_mask, input_hash, "REJECT", "runtime_invalid", NULL);
--+    return runtime_status;
--+  }
--+
--+  out_request->session_id = session->session_id;
--+  out_request->plan_id = plan_id;
--+  out_request->execution_slot = execution_slot;
--+  out_request->provider_id_len = provider->provider_id_len;
--+  memcpy(out_request->provider_id, provider->provider_id, provider->provider_id_len);
--+  out_request->provider_id[provider->provider_id_len] = '\0';
--+  out_request->tool_id_len = (uint8_t)tool_id_len;
--+  memcpy(out_request->tool_id, tool_id, tool_id_len + 1);
--+  out_request->tool_version = tool->version;
--+  out_request->capability_mask = capability_mask;
--+  out_request->input_hash = input_hash;
--+  out_request->arg_size = arg_size;
--+  if (arg_size > 0) {
--+    memcpy(out_request->arg_blob, arg_blob, arg_size);
--+  }
--+
--+  uint64_t previous_next_slot = session->next_execution_slot;
--+  shoots_error_code_t transition_status =
--+      shoots_session_transition_active_internal(session, execution_slot, out_error);
--+  if (transition_status != SHOOTS_OK) {
--+    return shoots_invariant_violation(engine, "execution slot transition failed",
--+                                      out_error);
--+  }
--+  if (session->next_execution_slot == UINT64_MAX) {
--+    session->next_execution_slot = 0;
--+  } else {
--+    session->next_execution_slot++;
--+  }
--+
--+  shoots_error_code_t ledger_status =
--+      shoots_provider_request_append_decision(
--+          engine, provider_id_value, tool_id, plan_id, execution_slot,
--+          capability_mask, input_hash, "ACCEPT", NULL, out_error);
--+  if (ledger_status != SHOOTS_OK) {
--+    session->has_active_execution = 0;
--+    session->active_execution_slot = 0;
--+    session->next_execution_slot = previous_next_slot;
--+    return ledger_status;
--+  }
--+  shoots_assert_invariants(engine);
--+  return SHOOTS_OK;
--+}
--+
-- shoots_error_code_t shoots_plan_internal(
--   shoots_engine_t *engine,
--   const shoots_plan_request_t *request,
--diff --git a/tools/engine/src/engine_internal.h b/tools/engine/src/engine_internal.h
--index da07536..f00a718 100644
----- a/tools/engine/src/engine_internal.h
--+++ b/tools/engine/src/engine_internal.h
--@@ -321,6 +321,20 @@ shoots_error_code_t shoots_provider_unregister_internal(
--   const char *provider_id,
--   shoots_error_info_t *out_error);
-- 
--+shoots_error_code_t shoots_provider_request_mint_internal(
--+  shoots_engine_t *engine,
--+  shoots_session_t *session,
--+  uint64_t plan_id,
--+  uint64_t execution_slot,
--+  const char *tool_id,
--+  const shoots_provider_descriptor_t *provider,
--+  uint64_t capability_mask,
--+  uint64_t input_hash,
--+  const uint8_t *arg_blob,
--+  uint32_t arg_size,
--+  shoots_provider_request_t *out_request,
--+  shoots_error_info_t *out_error);
--+
-- shoots_error_code_t shoots_session_create_internal(
--   shoots_engine_t *engine,
--   const char *intent_id,
--diff --git a/tools/engine/src/execution_spine.c b/tools/engine/src/execution_spine.c
--index 2a1ed34..560ce7d 100644
----- a/tools/engine/src/execution_spine.c
--+++ b/tools/engine/src/execution_spine.c
--@@ -20,3 +20,21 @@ shoots_error_code_t spine_record_result(
--   return shoots_result_append_internal(engine, session, command_id,
--                                        status, payload, out_record, out_error);
-- }
--+
--+shoots_error_code_t spine_mint_provider_request(
--+  shoots_engine_t *engine,
--+  shoots_session_t *session,
--+  uint64_t plan_id,
--+  uint64_t execution_slot,
--+  const char *tool_id,
--+  const shoots_provider_descriptor_t *provider,
--+  uint64_t capability_mask,
--+  uint64_t input_hash,
--+  const uint8_t *arg_blob,
--+  uint32_t arg_size,
--+  shoots_provider_request_t *out_request,
--+  shoots_error_info_t *out_error) {
--+  return shoots_provider_request_mint_internal(
--+      engine, session, plan_id, execution_slot, tool_id, provider,
--+      capability_mask, input_hash, arg_blob, arg_size, out_request, out_error);
--+}
--diff --git a/tools/engine/src/execution_spine.h b/tools/engine/src/execution_spine.h
--index 0b1b1fe..7414405 100644
----- a/tools/engine/src/execution_spine.h
--+++ b/tools/engine/src/execution_spine.h
--@@ -19,4 +19,18 @@ shoots_error_code_t spine_record_result(
--   shoots_result_record_t **out_record,
--   shoots_error_info_t *out_error);
-- 
--+shoots_error_code_t spine_mint_provider_request(
--+  shoots_engine_t *engine,
--+  shoots_session_t *session,
--+  uint64_t plan_id,
--+  uint64_t execution_slot,
--+  const char *tool_id,
--+  const shoots_provider_descriptor_t *provider,
--+  uint64_t capability_mask,
--+  uint64_t input_hash,
--+  const uint8_t *arg_blob,
--+  uint32_t arg_size,
--+  shoots_provider_request_t *out_request,
--+  shoots_error_info_t *out_error);
--+
-- #endif
--diff --git a/tools/engine/src/provider_runtime.h b/tools/engine/src/provider_runtime.h
--index 51b3834..386dc64 100644
----- a/tools/engine/src/provider_runtime.h
--+++ b/tools/engine/src/provider_runtime.h
--@@ -35,9 +35,12 @@ typedef struct shoots_provider_request {
--   uint64_t session_id;
--   uint64_t plan_id;
--   uint64_t execution_slot;
--+  uint8_t provider_id_len;
--+  char provider_id[SHOOTS_PROVIDER_ID_MAX];
--   uint8_t tool_id_len;
--   char tool_id[SHOOTS_PROVIDER_TOOL_ID_MAX];
--   uint32_t tool_version;
--+  uint64_t capability_mask;
--   uint64_t input_hash;
--   uint32_t arg_size;
--   uint8_t arg_blob[SHOOTS_PROVIDER_ARG_MAX_BYTES];
-diff --git a/tools/engine/src/engine.c b/tools/engine/src/engine.c
-index b9880f2..20bcabc 100644
---- a/tools/engine/src/engine.c
-+++ b/tools/engine/src/engine.c
-@@ -195,6 +195,12 @@ static void shoots_assert_invariants(const shoots_engine_t *engine) {
-     assert(engine->results_tail != NULL);
-     assert(engine->results_tail->next == NULL);
-   }
-+  if (engine->provider_requests_head == NULL) {
-+    assert(engine->provider_requests_tail == NULL);
-+  } else {
-+    assert(engine->provider_requests_tail != NULL);
-+    assert(engine->provider_requests_tail->next == NULL);
-+  }
-   shoots_command_record_t *command_cursor = engine->commands_head;
-   uint64_t last_command_seq = 0;
-   while (command_cursor != NULL) {
-@@ -779,12 +785,43 @@ static void shoots_provider_request_format_id(
-   }
- }
- 
-+static void shoots_provider_receipt_format_value(
-+  const char *value,
-+  uint8_t value_len,
-+  size_t value_max,
-+  char *buffer,
-+  size_t buffer_len) {
-+  if (buffer == NULL || buffer_len == 0) {
-+    return;
-+  }
-+  if (value == NULL) {
-+    strncpy(buffer, "(null)", buffer_len);
-+    buffer[buffer_len - 1] = '\0';
-+    return;
-+  }
-+  if (value_len == 0 || value_len >= value_max) {
-+    strncpy(buffer, "(invalid)", buffer_len);
-+    buffer[buffer_len - 1] = '\0';
-+    return;
-+  }
-+  size_t length = 0;
-+  for (; length + 1 < buffer_len && length < value_len; length++) {
-+    buffer[length] = value[length];
-+  }
-+  buffer[length] = '\0';
-+  if (length == 0) {
-+    strncpy(buffer, "(empty)", buffer_len);
-+    buffer[buffer_len - 1] = '\0';
-+  }
-+}
-+
- static shoots_error_code_t shoots_provider_request_append_decision(
-   shoots_engine_t *engine,
-   const char *provider_id,
-   const char *tool_id,
-   uint64_t plan_id,
-   uint64_t execution_slot,
-+  uint64_t request_id,
-   uint64_t capability_mask,
-   uint64_t input_hash,
-   const char *status,
-@@ -800,10 +837,12 @@ static shoots_error_code_t shoots_provider_request_append_decision(
-   int required = snprintf(NULL, 0,
-                           "provider_request status=%s provider_id=%s tool_id=%s"
-                           " plan_id=%" PRIu64 " execution_slot=%" PRIu64
-+                          " request_id=0x%016" PRIx64
-                           " capability_mask=0x%016" PRIx64
-                           " input_hash=0x%016" PRIx64,
-                           safe_status, safe_provider_id, safe_tool_id,
--                          plan_id, execution_slot, capability_mask, input_hash);
-+                          plan_id, execution_slot, request_id,
-+                          capability_mask, input_hash);
-   if (required < 0) {
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-                      "ledger format failed");
-@@ -829,10 +868,12 @@ static shoots_error_code_t shoots_provider_request_append_decision(
-   int written = snprintf(payload, payload_len + 1,
-                          "provider_request status=%s provider_id=%s tool_id=%s"
-                          " plan_id=%" PRIu64 " execution_slot=%" PRIu64
-+                         " request_id=0x%016" PRIx64
-                          " capability_mask=0x%016" PRIx64
-                          " input_hash=0x%016" PRIx64,
-                          safe_status, safe_provider_id, safe_tool_id,
--                         plan_id, execution_slot, capability_mask, input_hash);
-+                         plan_id, execution_slot, request_id,
-+                         capability_mask, input_hash);
-   if (written < 0) {
-     shoots_engine_alloc_free_internal(engine, payload);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-@@ -858,6 +899,150 @@ static shoots_error_code_t shoots_provider_request_append_decision(
-   return status_code;
- }
- 
-+static shoots_error_code_t shoots_provider_receipt_append_decision(
-+  shoots_engine_t *engine,
-+  const char *provider_id,
-+  const char *tool_id,
-+  uint64_t plan_id,
-+  uint64_t execution_slot,
-+  uint64_t request_id,
-+  const char *status,
-+  const char *reason,
-+  shoots_error_info_t *out_error) {
-+  const char *safe_provider_id = provider_id != NULL ? provider_id : "(null)";
-+  const char *safe_tool_id = tool_id != NULL ? tool_id : "(null)";
-+  const char *safe_status = status != NULL ? status : "UNKNOWN";
-+  const char *safe_reason = reason != NULL ? reason : "";
-+  const char *reason_format = reason != NULL && reason[0] != '\0'
-+                                  ? " reason=%s"
-+                                  : "%s";
-+  int required = snprintf(NULL, 0,
-+                          "provider_receipt status=%s provider_id=%s tool_id=%s"
-+                          " plan_id=%" PRIu64 " execution_slot=%" PRIu64
-+                          " request_id=0x%016" PRIx64,
-+                          safe_status, safe_provider_id, safe_tool_id,
-+                          plan_id, execution_slot, request_id);
-+  if (required < 0) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  int reason_required = snprintf(NULL, 0, reason_format, safe_reason);
-+  if (reason_required < 0) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  size_t payload_len = (size_t)required + (size_t)reason_required;
-+  if (payload_len > SHOOTS_LEDGER_MAX_BYTES) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger payload too large");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  char *payload = (char *)shoots_engine_alloc_internal(
-+      engine, payload_len + 1, out_error);
-+  if (payload == NULL) {
-+    return SHOOTS_ERR_OUT_OF_MEMORY;
-+  }
-+  int written = snprintf(payload, payload_len + 1,
-+                         "provider_receipt status=%s provider_id=%s tool_id=%s"
-+                         " plan_id=%" PRIu64 " execution_slot=%" PRIu64
-+                         " request_id=0x%016" PRIx64,
-+                         safe_status, safe_provider_id, safe_tool_id,
-+                         plan_id, execution_slot, request_id);
-+  if (written < 0) {
-+    shoots_engine_alloc_free_internal(engine, payload);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  if (reason_required > 0 && reason != NULL && reason[0] != '\0') {
-+    int reason_written = snprintf(payload + written,
-+                                  payload_len + 1 - (size_t)written,
-+                                  " reason=%s",
-+                                  safe_reason);
-+    if (reason_written < 0) {
-+      shoots_engine_alloc_free_internal(engine, payload);
-+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                       "ledger format failed");
-+      return SHOOTS_ERR_INVALID_STATE;
-+    }
-+  }
-+  shoots_ledger_entry_t *entry = NULL;
-+  shoots_error_code_t status_code = shoots_ledger_append_internal(
-+      engine, SHOOTS_LEDGER_ENTRY_DECISION, payload, &entry, out_error);
-+  shoots_engine_alloc_free_internal(engine, payload);
-+  return status_code;
-+}
-+
-+static uint64_t shoots_request_hash_update(uint64_t hash,
-+                                           const void *bytes,
-+                                           size_t length) {
-+  const unsigned char *cursor = (const unsigned char *)bytes;
-+  for (size_t index = 0; index < length; index++) {
-+    hash ^= (uint64_t)cursor[index];
-+    hash *= 1099511628211ull;
-+  }
-+  return hash;
-+}
-+
-+static uint64_t shoots_provider_request_id(
-+  uint64_t session_id,
-+  uint64_t plan_id,
-+  uint64_t execution_slot,
-+  const shoots_provider_descriptor_t *provider,
-+  const char *tool_id,
-+  uint32_t tool_version,
-+  uint64_t capability_mask,
-+  uint64_t input_hash) {
-+  uint64_t hash = 14695981039346656037ull;
-+  hash = shoots_request_hash_update(hash, &session_id, sizeof(session_id));
-+  hash = shoots_request_hash_update(hash, &plan_id, sizeof(plan_id));
-+  hash = shoots_request_hash_update(hash, &execution_slot, sizeof(execution_slot));
-+  if (provider != NULL) {
-+    hash = shoots_request_hash_update(hash, provider->provider_id,
-+                                      provider->provider_id_len);
-+  }
-+  if (tool_id != NULL) {
-+    hash = shoots_request_hash_update(hash, tool_id, strlen(tool_id));
-+  }
-+  hash = shoots_request_hash_update(hash, &tool_version, sizeof(tool_version));
-+  hash = shoots_request_hash_update(hash, &capability_mask, sizeof(capability_mask));
-+  hash = shoots_request_hash_update(hash, &input_hash, sizeof(input_hash));
-+  return hash;
-+}
-+
-+static void shoots_register_provider_request(
-+  shoots_engine_t *engine,
-+  shoots_provider_request_record_t *record) {
-+  if (engine == NULL || record == NULL) {
-+    return;
-+  }
-+  if (engine->provider_requests_tail == NULL) {
-+    engine->provider_requests_head = record;
-+    engine->provider_requests_tail = record;
-+    return;
-+  }
-+  engine->provider_requests_tail->next = record;
-+  engine->provider_requests_tail = record;
-+}
-+
-+static shoots_provider_request_record_t *shoots_find_provider_request(
-+  shoots_engine_t *engine,
-+  uint64_t request_id) {
-+  if (engine == NULL || request_id == 0) {
-+    return NULL;
-+  }
-+  shoots_provider_request_record_t *cursor = engine->provider_requests_head;
-+  while (cursor != NULL) {
-+    if (cursor->request_id == request_id) {
-+      return cursor;
-+    }
-+    cursor = cursor->next;
-+  }
-+  return NULL;
-+}
-+
- static void shoots_tool_reject_reason_set(shoots_tool_reject_reason_t *reason,
-                                           shoots_tool_reject_code_t code,
-                                           const char *token) {
-@@ -1448,6 +1633,8 @@ shoots_error_code_t shoots_engine_create(const shoots_config_t *config,
-   engine->tools_locked = 0;
-   engine->results_head = NULL;
-   engine->results_tail = NULL;
-+  engine->provider_requests_head = NULL;
-+  engine->provider_requests_tail = NULL;
-   engine->commands_head = NULL;
-   engine->commands_tail = NULL;
-   engine->commands_entry_count = 0;
-@@ -2700,10 +2887,11 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   char provider_id_value[SHOOTS_PROVIDER_ID_MAX];
-   shoots_provider_request_format_id(provider, provider_id_value,
-                                     sizeof(provider_id_value));
-+  uint64_t request_id = 0;
-   if (session->state != SHOOTS_SESSION_STATE_ACTIVE) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "session_inactive", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "session_inactive", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-                      "session not active");
-     return SHOOTS_ERR_INVALID_STATE;
-@@ -2711,7 +2899,7 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   if (plan_id == 0) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "plan_id_invalid", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "plan_id_invalid", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-                      "plan_id invalid");
-     return SHOOTS_ERR_INVALID_ARGUMENT;
-@@ -2719,7 +2907,7 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   if (!shoots_intent_exists(engine, session->intent_id)) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "intent_missing", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "intent_missing", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-                      "intent missing");
-     return SHOOTS_ERR_INVALID_STATE;
-@@ -2727,7 +2915,7 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   if (shoots_session_find_plan(session, plan_id) == NULL) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "plan_not_found", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "plan_not_found", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-                      "plan not found");
-     return SHOOTS_ERR_INVALID_ARGUMENT;
-@@ -2735,7 +2923,7 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   if (tool_id == NULL || tool_id[0] == '\0') {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "tool_id_invalid", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "tool_id_invalid", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-                      "tool_id is null or empty");
-     return SHOOTS_ERR_INVALID_ARGUMENT;
-@@ -2744,7 +2932,7 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   if (tool_id_len >= SHOOTS_PROVIDER_TOOL_ID_MAX) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "tool_id_too_long", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "tool_id_too_long", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-                      "tool_id too long");
-     return SHOOTS_ERR_INVALID_ARGUMENT;
-@@ -2752,7 +2940,7 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   if (provider == NULL) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "provider_missing", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "provider_missing", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-                      "provider is null");
-     return SHOOTS_ERR_INVALID_ARGUMENT;
-@@ -2762,14 +2950,14 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   if (provider_status != SHOOTS_OK) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "provider_invalid", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "provider_invalid", NULL);
-     return provider_status;
-   }
-   const shoots_tool_record_t *tool = shoots_tool_find(engine, tool_id);
-   if (tool == NULL) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "tool_not_found", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "tool_not_found", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-                      "tool not found");
-     return SHOOTS_ERR_INVALID_ARGUMENT;
-@@ -2787,11 +2975,14 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   if (registered_provider == NULL) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "provider_not_registered", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "provider_not_registered", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-                      "provider not registered");
-     return SHOOTS_ERR_INVALID_ARGUMENT;
-   }
-+  request_id = shoots_provider_request_id(
-+      session->session_id, plan_id, execution_slot, registered_provider,
-+      tool_id, tool->version, capability_mask, input_hash);
-   uint32_t required_category = 0;
-   if (tool->category == SHOOTS_TOOL_CATEGORY_EXECUTION) {
-     required_category = SHOOTS_PROVIDER_TOOL_CATEGORY_EXECUTION;
-@@ -2800,7 +2991,7 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   } else {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "tool_category_invalid", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "tool_category_invalid", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-                      "tool category invalid");
-     return SHOOTS_ERR_INVALID_ARGUMENT;
-@@ -2808,7 +2999,7 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   if ((registered_provider->supported_tool_categories & required_category) == 0) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "category_mismatch", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "category_mismatch", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-                      "provider category mismatch");
-     return SHOOTS_ERR_INVALID_ARGUMENT;
-@@ -2816,7 +3007,7 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   if ((tool->determinism_flags & ~registered_provider->guarantees_mask) != 0) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "guarantee_mismatch", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "guarantee_mismatch", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-                      "provider guarantees mismatch");
-     return SHOOTS_ERR_INVALID_ARGUMENT;
-@@ -2824,7 +3015,7 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   if ((capability_mask & ~tool->capabilities) != 0) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "capability_mismatch", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "capability_mismatch", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-                      "capability mask invalid");
-     return SHOOTS_ERR_INVALID_ARGUMENT;
-@@ -2832,7 +3023,7 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   if (arg_size > SHOOTS_PROVIDER_ARG_MAX_BYTES) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "arg_too_large", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "arg_too_large", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-                      "arg size too large");
-     return SHOOTS_ERR_INVALID_ARGUMENT;
-@@ -2840,7 +3031,7 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   if (arg_size > 0 && arg_blob == NULL) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "arg_missing", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "arg_missing", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-                      "arg blob missing");
-     return SHOOTS_ERR_INVALID_ARGUMENT;
-@@ -2848,7 +3039,7 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   if (execution_slot == 0) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "execution_slot_invalid", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "execution_slot_invalid", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-                      "execution_slot invalid");
-     return SHOOTS_ERR_INVALID_ARGUMENT;
-@@ -2856,7 +3047,7 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   if (session->has_active_execution) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "execution_active", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "execution_active", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-                      "execution already active");
-     return SHOOTS_ERR_INVALID_STATE;
-@@ -2865,13 +3056,13 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-       execution_slot <= session->terminal_execution_slot) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "execution_slot_terminal", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "execution_slot_terminal", NULL);
-     return shoots_invariant_violation(engine, "execution slot terminal", out_error);
-   }
-   if (session->next_execution_slot == 0) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "execution_slots_exhausted", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "execution_slots_exhausted", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-                      "execution slots exhausted");
-     return SHOOTS_ERR_INVALID_STATE;
-@@ -2879,7 +3070,7 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   if (execution_slot != session->next_execution_slot) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "execution_slot_out_of_order", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "execution_slot_out_of_order", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-                      "execution slot out of order");
-     return SHOOTS_ERR_INVALID_ARGUMENT;
-@@ -2889,13 +3080,14 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   if (runtime_status != SHOOTS_OK) {
-     shoots_provider_request_append_decision(
-         engine, provider_id_value, tool_id, plan_id, execution_slot,
--        capability_mask, input_hash, "REJECT", "runtime_invalid", NULL);
-+        request_id, capability_mask, input_hash, "REJECT", "runtime_invalid", NULL);
-     return runtime_status;
-   }
- 
-   out_request->session_id = session->session_id;
-   out_request->plan_id = plan_id;
-   out_request->execution_slot = execution_slot;
-+  out_request->request_id = request_id;
-   out_request->provider_id_len = provider->provider_id_len;
-   memcpy(out_request->provider_id, provider->provider_id, provider->provider_id_len);
-   out_request->provider_id[provider->provider_id_len] = '\0';
-@@ -2909,10 +3101,32 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-     memcpy(out_request->arg_blob, arg_blob, arg_size);
-   }
- 
-+  shoots_provider_request_record_t *record =
-+      (shoots_provider_request_record_t *)shoots_engine_alloc_internal(
-+          engine, sizeof(*record), out_error);
-+  if (record == NULL) {
-+    return SHOOTS_ERR_OUT_OF_MEMORY;
-+  }
-+  memset(record, 0, sizeof(*record));
-+  record->request_id = request_id;
-+  record->session_id = session->session_id;
-+  record->plan_id = plan_id;
-+  record->execution_slot = execution_slot;
-+  record->provider_id_len = out_request->provider_id_len;
-+  memcpy(record->provider_id, out_request->provider_id, out_request->provider_id_len + 1);
-+  record->tool_id_len = out_request->tool_id_len;
-+  memcpy(record->tool_id, out_request->tool_id, out_request->tool_id_len + 1);
-+  record->tool_version = out_request->tool_version;
-+  record->capability_mask = capability_mask;
-+  record->input_hash = input_hash;
-+  record->received = 0;
-+  record->next = NULL;
-+
-   uint64_t previous_next_slot = session->next_execution_slot;
-   shoots_error_code_t transition_status =
-       shoots_session_transition_active_internal(session, execution_slot, out_error);
-   if (transition_status != SHOOTS_OK) {
-+    shoots_engine_alloc_free_internal(engine, record);
-     return shoots_invariant_violation(engine, "execution slot transition failed",
-                                       out_error);
-   }
-@@ -2925,11 +3139,209 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   shoots_error_code_t ledger_status =
-       shoots_provider_request_append_decision(
-           engine, provider_id_value, tool_id, plan_id, execution_slot,
--          capability_mask, input_hash, "ACCEPT", NULL, out_error);
-+          request_id, capability_mask, input_hash, "ACCEPT", NULL, out_error);
-   if (ledger_status != SHOOTS_OK) {
-     session->has_active_execution = 0;
-     session->active_execution_slot = 0;
-     session->next_execution_slot = previous_next_slot;
-+    shoots_engine_alloc_free_internal(engine, record);
-+    return ledger_status;
-+  }
-+  shoots_register_provider_request(engine, record);
-+  shoots_assert_invariants(engine);
-+  return SHOOTS_OK;
-+}
-+
-+shoots_error_code_t shoots_provider_receipt_verify_internal(
-+  shoots_engine_t *engine,
-+  const shoots_provider_receipt_t *receipt,
-+  shoots_error_info_t *out_error) {
-+  shoots_error_clear(out_error);
-+  if (receipt == NULL) {
-+    shoots_provider_receipt_append_decision(
-+        engine, "(null)", "(null)", 0, 0, 0, "REJECT", "receipt_null", NULL);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "receipt is null");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  shoots_error_code_t engine_status = shoots_validate_engine(engine, out_error);
-+  if (engine_status != SHOOTS_OK) {
-+    return engine_status;
-+  }
-+  char provider_id_value[SHOOTS_PROVIDER_ID_MAX];
-+  char tool_id_value[SHOOTS_PROVIDER_TOOL_ID_MAX];
-+  shoots_provider_receipt_format_value(receipt->provider_id,
-+                                       receipt->provider_id_len,
-+                                       SHOOTS_PROVIDER_ID_MAX,
-+                                       provider_id_value,
-+                                       sizeof(provider_id_value));
-+  shoots_provider_receipt_format_value(receipt->tool_id,
-+                                       receipt->tool_id_len,
-+                                       SHOOTS_PROVIDER_TOOL_ID_MAX,
-+                                       tool_id_value,
-+                                       sizeof(tool_id_value));
-+  if (receipt->request_id == 0) {
-+    shoots_provider_receipt_append_decision(
-+        engine, provider_id_value, tool_id_value, receipt->plan_id,
-+        receipt->execution_slot, receipt->request_id, "REJECT",
-+        "request_id_invalid", NULL);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "request_id invalid");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  if (receipt->provider_id_len == 0 ||
-+      receipt->provider_id_len >= SHOOTS_PROVIDER_ID_MAX) {
-+    shoots_provider_receipt_append_decision(
-+        engine, provider_id_value, tool_id_value, receipt->plan_id,
-+        receipt->execution_slot, receipt->request_id, "REJECT",
-+        "provider_id_invalid", NULL);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "provider_id invalid");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  size_t provider_id_len =
-+      strnlen(receipt->provider_id, SHOOTS_PROVIDER_ID_MAX);
-+  if (provider_id_len != receipt->provider_id_len) {
-+    shoots_provider_receipt_append_decision(
-+        engine, provider_id_value, tool_id_value, receipt->plan_id,
-+        receipt->execution_slot, receipt->request_id, "REJECT",
-+        "provider_id_invalid", NULL);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "provider_id invalid");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  if (receipt->tool_id_len == 0 ||
-+      receipt->tool_id_len >= SHOOTS_PROVIDER_TOOL_ID_MAX) {
-+    shoots_provider_receipt_append_decision(
-+        engine, provider_id_value, tool_id_value, receipt->plan_id,
-+        receipt->execution_slot, receipt->request_id, "REJECT",
-+        "tool_id_invalid", NULL);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "tool_id invalid");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  size_t tool_id_len =
-+      strnlen(receipt->tool_id, SHOOTS_PROVIDER_TOOL_ID_MAX);
-+  if (tool_id_len != receipt->tool_id_len) {
-+    shoots_provider_receipt_append_decision(
-+        engine, provider_id_value, tool_id_value, receipt->plan_id,
-+        receipt->execution_slot, receipt->request_id, "REJECT",
-+        "tool_id_invalid", NULL);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "tool_id invalid");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  if (receipt->output_size > SHOOTS_PROVIDER_OUTPUT_MAX_BYTES) {
-+    shoots_provider_receipt_append_decision(
-+        engine, provider_id_value, tool_id_value, receipt->plan_id,
-+        receipt->execution_slot, receipt->request_id, "REJECT",
-+        "output_size_invalid", NULL);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "output_size invalid");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  if (receipt->result_code < SHOOTS_PROVIDER_RESULT_SUCCESS ||
-+      receipt->result_code > SHOOTS_PROVIDER_RESULT_REJECTED) {
-+    shoots_provider_receipt_append_decision(
-+        engine, provider_id_value, tool_id_value, receipt->plan_id,
-+        receipt->execution_slot, receipt->request_id, "REJECT",
-+        "result_code_invalid", NULL);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "result_code invalid");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  shoots_provider_request_record_t *record =
-+      shoots_find_provider_request(engine, receipt->request_id);
-+  if (record == NULL) {
-+    shoots_provider_receipt_append_decision(
-+        engine, provider_id_value, tool_id_value, receipt->plan_id,
-+        receipt->execution_slot, receipt->request_id, "REJECT",
-+        "request_not_found", NULL);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "request not found");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  if (record->received) {
-+    shoots_provider_receipt_append_decision(
-+        engine, provider_id_value, tool_id_value, receipt->plan_id,
-+        receipt->execution_slot, receipt->request_id, "REJECT",
-+        "receipt_duplicate", NULL);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "receipt already recorded");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  if (record->session_id != receipt->session_id) {
-+    shoots_provider_receipt_append_decision(
-+        engine, provider_id_value, tool_id_value, receipt->plan_id,
-+        receipt->execution_slot, receipt->request_id, "REJECT",
-+        "session_mismatch", NULL);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "session mismatch");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  if (record->plan_id != receipt->plan_id) {
-+    shoots_provider_receipt_append_decision(
-+        engine, provider_id_value, tool_id_value, receipt->plan_id,
-+        receipt->execution_slot, receipt->request_id, "REJECT",
-+        "plan_mismatch", NULL);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "plan mismatch");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  if (record->execution_slot != receipt->execution_slot) {
-+    shoots_provider_receipt_append_decision(
-+        engine, provider_id_value, tool_id_value, receipt->plan_id,
-+        receipt->execution_slot, receipt->request_id, "REJECT",
-+        "execution_slot_mismatch", NULL);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "execution_slot mismatch");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  if (record->provider_id_len != receipt->provider_id_len ||
-+      memcmp(record->provider_id, receipt->provider_id, record->provider_id_len) != 0) {
-+    shoots_provider_receipt_append_decision(
-+        engine, provider_id_value, tool_id_value, receipt->plan_id,
-+        receipt->execution_slot, receipt->request_id, "REJECT",
-+        "provider_id_mismatch", NULL);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "provider_id mismatch");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  if (record->tool_id_len != receipt->tool_id_len ||
-+      memcmp(record->tool_id, receipt->tool_id, record->tool_id_len) != 0) {
-+    shoots_provider_receipt_append_decision(
-+        engine, provider_id_value, tool_id_value, receipt->plan_id,
-+        receipt->execution_slot, receipt->request_id, "REJECT",
-+        "tool_id_mismatch", NULL);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "tool_id mismatch");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  if (record->tool_version != receipt->tool_version) {
-+    shoots_provider_receipt_append_decision(
-+        engine, provider_id_value, tool_id_value, receipt->plan_id,
-+        receipt->execution_slot, receipt->request_id, "REJECT",
-+        "tool_version_mismatch", NULL);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "tool_version mismatch");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  if (record->input_hash != receipt->input_hash) {
-+    shoots_provider_receipt_append_decision(
-+        engine, provider_id_value, tool_id_value, receipt->plan_id,
-+        receipt->execution_slot, receipt->request_id, "REJECT",
-+        "input_hash_mismatch", NULL);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "input_hash mismatch");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  record->received = 1;
-+  shoots_error_code_t ledger_status =
-+      shoots_provider_receipt_append_decision(
-+          engine, provider_id_value, tool_id_value, receipt->plan_id,
-+          receipt->execution_slot, receipt->request_id, "ACCEPT", NULL, out_error);
-+  if (ledger_status != SHOOTS_OK) {
-+    record->received = 0;
-     return ledger_status;
-   }
-   shoots_assert_invariants(engine);
-diff --git a/tools/engine/src/engine_internal.h b/tools/engine/src/engine_internal.h
-index f00a718..6a50ce5 100644
---- a/tools/engine/src/engine_internal.h
-+++ b/tools/engine/src/engine_internal.h
-@@ -176,6 +176,22 @@ typedef struct shoots_result_record {
-   struct shoots_result_record *next;
- } shoots_result_record_t;
- 
-+typedef struct shoots_provider_request_record {
-+  uint64_t request_id;
-+  uint64_t session_id;
-+  uint64_t plan_id;
-+  uint64_t execution_slot;
-+  uint8_t  provider_id_len;
-+  char     provider_id[SHOOTS_PROVIDER_ID_MAX];
-+  uint8_t  tool_id_len;
-+  char     tool_id[SHOOTS_PROVIDER_TOOL_ID_MAX];
-+  uint32_t tool_version;
-+  uint64_t capability_mask;
-+  uint64_t input_hash;
-+  uint8_t  received;
-+  struct shoots_provider_request_record *next;
-+} shoots_provider_request_record_t;
-+
- #define SHOOTS_SESSION_MAX_PLANS 4u
- #define SHOOTS_SESSION_PLAN_MAX_TOOLS 64u
- #define SHOOTS_ENGINE_MAX_PROVIDERS 8u
-@@ -284,6 +300,9 @@ struct shoots_engine {
-   struct shoots_result_record *results_head;
-   struct shoots_result_record *results_tail;
- 
-+  struct shoots_provider_request_record *provider_requests_head;
-+  struct shoots_provider_request_record *provider_requests_tail;
-+
-   shoots_command_record_t *commands_head;
-   shoots_command_record_t *commands_tail;
-   size_t                   commands_entry_count;
-@@ -335,6 +354,11 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   shoots_provider_request_t *out_request,
-   shoots_error_info_t *out_error);
- 
-+shoots_error_code_t shoots_provider_receipt_verify_internal(
-+  shoots_engine_t *engine,
-+  const shoots_provider_receipt_t *receipt,
-+  shoots_error_info_t *out_error);
-+
- shoots_error_code_t shoots_session_create_internal(
-   shoots_engine_t *engine,
-   const char *intent_id,
-diff --git a/tools/engine/src/execution_spine.c b/tools/engine/src/execution_spine.c
-index 560ce7d..72a3c1b 100644
---- a/tools/engine/src/execution_spine.c
-+++ b/tools/engine/src/execution_spine.c
-@@ -38,3 +38,10 @@ shoots_error_code_t spine_mint_provider_request(
-       engine, session, plan_id, execution_slot, tool_id, provider,
-       capability_mask, input_hash, arg_blob, arg_size, out_request, out_error);
- }
-+
-+shoots_error_code_t spine_verify_provider_receipt(
-+  shoots_engine_t *engine,
-+  const shoots_provider_receipt_t *receipt,
-+  shoots_error_info_t *out_error) {
-+  return shoots_provider_receipt_verify_internal(engine, receipt, out_error);
-+}
-diff --git a/tools/engine/src/execution_spine.h b/tools/engine/src/execution_spine.h
-index 7414405..9c2c805 100644
---- a/tools/engine/src/execution_spine.h
-+++ b/tools/engine/src/execution_spine.h
-@@ -33,4 +33,9 @@ shoots_error_code_t spine_mint_provider_request(
-   shoots_provider_request_t *out_request,
-   shoots_error_info_t *out_error);
- 
-+shoots_error_code_t spine_verify_provider_receipt(
-+  shoots_engine_t *engine,
-+  const shoots_provider_receipt_t *receipt,
-+  shoots_error_info_t *out_error);
-+
- #endif
-diff --git a/tools/engine/src/provider_runtime.h b/tools/engine/src/provider_runtime.h
-index 386dc64..c31b5c8 100644
---- a/tools/engine/src/provider_runtime.h
-+++ b/tools/engine/src/provider_runtime.h
-@@ -35,6 +35,7 @@ typedef struct shoots_provider_request {
-   uint64_t session_id;
-   uint64_t plan_id;
-   uint64_t execution_slot;
-+  uint64_t request_id;
-   uint8_t provider_id_len;
-   char provider_id[SHOOTS_PROVIDER_ID_MAX];
-   uint8_t tool_id_len;
-@@ -50,6 +51,9 @@ typedef struct shoots_provider_receipt {
-   uint64_t session_id;
-   uint64_t plan_id;
-   uint64_t execution_slot;
-+  uint64_t request_id;
-+  uint8_t provider_id_len;
-+  char provider_id[SHOOTS_PROVIDER_ID_MAX];
-   uint8_t tool_id_len;
-   char tool_id[SHOOTS_PROVIDER_TOOL_ID_MAX];
-   uint32_t tool_version;
diff --git a/.ai/patches/patch-2026-01-30-01-53-32.diff b/.ai/patches/patch-2026-01-30-01-53-32.diff
deleted file mode 100644
index c78b849..0000000
--- a/.ai/patches/patch-2026-01-30-01-53-32.diff
+++ /dev/null
@@ -1,196 +0,0 @@
-diff --git a/tools/engine/src/engine.c b/tools/engine/src/engine.c
-index 50ef5fd..8602937 100644
---- a/tools/engine/src/engine.c
-+++ b/tools/engine/src/engine.c
-@@ -977,6 +977,84 @@ static shoots_error_code_t shoots_provider_receipt_append_decision(
-   return status_code;
- }
- 
-+static shoots_error_code_t shoots_provider_terminal_append_decision(
-+  shoots_engine_t *engine,
-+  const char *provider_id,
-+  const char *tool_id,
-+  uint64_t plan_id,
-+  uint64_t execution_slot,
-+  uint64_t request_id,
-+  const char *result_text,
-+  const char *status,
-+  const char *reason,
-+  shoots_error_info_t *out_error) {
-+  const char *safe_provider_id = provider_id != NULL ? provider_id : "(null)";
-+  const char *safe_tool_id = tool_id != NULL ? tool_id : "(null)";
-+  const char *safe_status = status != NULL ? status : "UNKNOWN";
-+  const char *safe_result = result_text != NULL ? result_text : "UNKNOWN";
-+  const char *safe_reason = reason != NULL ? reason : "";
-+  const char *reason_format = reason != NULL && reason[0] != '\0'
-+                                  ? " reason=%s"
-+                                  : "%s";
-+  int required = snprintf(NULL, 0,
-+                          "provider_terminal status=%s provider_id=%s tool_id=%s"
-+                          " plan_id=%" PRIu64 " execution_slot=%" PRIu64
-+                          " request_id=0x%016" PRIx64 " result=%s",
-+                          safe_status, safe_provider_id, safe_tool_id,
-+                          plan_id, execution_slot, request_id, safe_result);
-+  if (required < 0) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  int reason_required = snprintf(NULL, 0, reason_format, safe_reason);
-+  if (reason_required < 0) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  size_t payload_len = (size_t)required + (size_t)reason_required;
-+  if (payload_len > SHOOTS_LEDGER_MAX_BYTES) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger payload too large");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  char *payload = (char *)shoots_engine_alloc_internal(
-+      engine, payload_len + 1, out_error);
-+  if (payload == NULL) {
-+    return SHOOTS_ERR_OUT_OF_MEMORY;
-+  }
-+  int written = snprintf(payload, payload_len + 1,
-+                         "provider_terminal status=%s provider_id=%s tool_id=%s"
-+                         " plan_id=%" PRIu64 " execution_slot=%" PRIu64
-+                         " request_id=0x%016" PRIx64 " result=%s",
-+                         safe_status, safe_provider_id, safe_tool_id,
-+                         plan_id, execution_slot, request_id, safe_result);
-+  if (written < 0) {
-+    shoots_engine_alloc_free_internal(engine, payload);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  if (reason_required > 0 && reason != NULL && reason[0] != '\0') {
-+    int reason_written = snprintf(payload + written,
-+                                  payload_len + 1 - (size_t)written,
-+                                  " reason=%s",
-+                                  safe_reason);
-+    if (reason_written < 0) {
-+      shoots_engine_alloc_free_internal(engine, payload);
-+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                       "ledger format failed");
-+      return SHOOTS_ERR_INVALID_STATE;
-+    }
-+  }
-+  shoots_ledger_entry_t *entry = NULL;
-+  shoots_error_code_t status_code = shoots_ledger_append_internal(
-+      engine, SHOOTS_LEDGER_ENTRY_DECISION, payload, &entry, out_error);
-+  shoots_engine_alloc_free_internal(engine, payload);
-+  return status_code;
-+}
-+
- static const char *shoots_provider_result_text(shoots_provider_result_code_t code) {
-   switch (code) {
-     case SHOOTS_PROVIDER_RESULT_SUCCESS:
-@@ -3379,7 +3457,7 @@ shoots_error_code_t shoots_provider_receipt_map_terminal_internal(
-     return engine_status;
-   }
-   if (receipt == NULL) {
--    shoots_provider_receipt_append_decision(
-+    shoots_provider_terminal_append_decision(
-         engine, "(null)", "(null)", 0, 0, 0, "UNKNOWN", "REJECT", "receipt_null", NULL);
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-                      "receipt is null");
-@@ -3405,7 +3483,7 @@ shoots_error_code_t shoots_provider_receipt_map_terminal_internal(
-   const char *result_text = shoots_provider_result_text(receipt->result_code);
-   shoots_session_t *session = shoots_find_session(engine, receipt->session_id);
-   if (session == NULL) {
--    shoots_provider_receipt_append_decision(
-+    shoots_provider_terminal_append_decision(
-         engine, provider_id_value, tool_id_value, receipt->plan_id,
-         receipt->execution_slot, receipt->request_id, result_text, "REJECT",
-         "session_missing", NULL);
-@@ -3415,14 +3493,14 @@ shoots_error_code_t shoots_provider_receipt_map_terminal_internal(
-   }
-   shoots_error_code_t session_status = shoots_validate_session(engine, session, out_error);
-   if (session_status != SHOOTS_OK) {
--    shoots_provider_receipt_append_decision(
-+    shoots_provider_terminal_append_decision(
-         engine, provider_id_value, tool_id_value, receipt->plan_id,
-         receipt->execution_slot, receipt->request_id, result_text, "REJECT",
-         "session_invalid", NULL);
-     return session_status;
-   }
-   if (session->state != SHOOTS_SESSION_STATE_ACTIVE) {
--    shoots_provider_receipt_append_decision(
-+    shoots_provider_terminal_append_decision(
-         engine, provider_id_value, tool_id_value, receipt->plan_id,
-         receipt->execution_slot, receipt->request_id, result_text, "REJECT",
-         "session_inactive", NULL);
-@@ -3432,7 +3510,7 @@ shoots_error_code_t shoots_provider_receipt_map_terminal_internal(
-   }
-   if (!session->has_active_execution ||
-       session->active_execution_slot != receipt->execution_slot) {
--    shoots_provider_receipt_append_decision(
-+    shoots_provider_terminal_append_decision(
-         engine, provider_id_value, tool_id_value, receipt->plan_id,
-         receipt->execution_slot, receipt->request_id, result_text, "REJECT",
-         "execution_slot_inactive", NULL);
-@@ -3442,7 +3520,7 @@ shoots_error_code_t shoots_provider_receipt_map_terminal_internal(
-   }
-   if (session->has_terminal_execution &&
-       receipt->execution_slot <= session->terminal_execution_slot) {
--    shoots_provider_receipt_append_decision(
-+    shoots_provider_terminal_append_decision(
-         engine, provider_id_value, tool_id_value, receipt->plan_id,
-         receipt->execution_slot, receipt->request_id, result_text, "REJECT",
-         "execution_slot_terminal", NULL);
-@@ -3450,7 +3528,7 @@ shoots_error_code_t shoots_provider_receipt_map_terminal_internal(
-   }
-   if (shoots_find_result_for_slot(engine, session->session_id,
-                                   receipt->execution_slot) != NULL) {
--    shoots_provider_receipt_append_decision(
-+    shoots_provider_terminal_append_decision(
-         engine, provider_id_value, tool_id_value, receipt->plan_id,
-         receipt->execution_slot, receipt->request_id, result_text, "REJECT",
-         "terminal_result_exists", NULL);
-@@ -3463,7 +3541,7 @@ shoots_error_code_t shoots_provider_receipt_map_terminal_internal(
-   int command_id_len = snprintf(command_id_buffer, sizeof(command_id_buffer),
-                                 "provider_request=0x%016" PRIx64, receipt->request_id);
-   if (command_id_len < 0 || (size_t)command_id_len >= sizeof(command_id_buffer)) {
--    shoots_provider_receipt_append_decision(
-+    shoots_provider_terminal_append_decision(
-         engine, provider_id_value, tool_id_value, receipt->plan_id,
-         receipt->execution_slot, receipt->request_id, result_text, "REJECT",
-         "command_id_invalid", NULL);
-@@ -3477,7 +3555,7 @@ shoots_error_code_t shoots_provider_receipt_map_terminal_internal(
-                              provider_id_value, tool_id_value, receipt->request_id,
-                              result_text, receipt->output_size);
-   if (payload_len < 0) {
--    shoots_provider_receipt_append_decision(
-+    shoots_provider_terminal_append_decision(
-         engine, provider_id_value, tool_id_value, receipt->plan_id,
-         receipt->execution_slot, receipt->request_id, result_text, "REJECT",
-         "payload_invalid", NULL);
-@@ -3486,7 +3564,7 @@ shoots_error_code_t shoots_provider_receipt_map_terminal_internal(
-     return SHOOTS_ERR_INVALID_STATE;
-   }
-   if ((size_t)payload_len > SHOOTS_RESULT_MAX_BYTES) {
--    shoots_provider_receipt_append_decision(
-+    shoots_provider_terminal_append_decision(
-         engine, provider_id_value, tool_id_value, receipt->plan_id,
-         receipt->execution_slot, receipt->request_id, result_text, "REJECT",
-         "payload_too_large", NULL);
-@@ -3501,7 +3579,7 @@ shoots_error_code_t shoots_provider_receipt_map_terminal_internal(
-                       strlen(" status=") + strlen(status_text) +
-                       strlen(" payload=") + (size_t)payload_len;
-   if (ledger_len > SHOOTS_LEDGER_MAX_BYTES) {
--    shoots_provider_receipt_append_decision(
-+    shoots_provider_terminal_append_decision(
-         engine, provider_id_value, tool_id_value, receipt->plan_id,
-         receipt->execution_slot, receipt->request_id, result_text, "REJECT",
-         "ledger_too_large", NULL);
-@@ -3600,7 +3678,7 @@ shoots_error_code_t shoots_provider_receipt_map_terminal_internal(
-                                       out_error);
-   }
-   shoots_error_code_t decision_status =
--      shoots_provider_receipt_append_decision(
-+      shoots_provider_terminal_append_decision(
-           engine, provider_id_value, tool_id_value, receipt->plan_id,
-           receipt->execution_slot, receipt->request_id, result_text, "ACCEPT",
-           NULL, out_error);
diff --git a/.ai/patches/patch-2026-01-30-02-18-58.diff b/.ai/patches/patch-2026-01-30-02-18-58.diff
deleted file mode 100644
index 555658d..0000000
--- a/.ai/patches/patch-2026-01-30-02-18-58.diff
+++ /dev/null
@@ -1,132 +0,0 @@
-diff --git a/tools/engine/src/engine.c b/tools/engine/src/engine.c
-index 8602937..6e61247 100644
---- a/tools/engine/src/engine.c
-+++ b/tools/engine/src/engine.c
-@@ -3215,6 +3215,10 @@ shoots_error_code_t shoots_provider_request_mint_internal(
-   record->tool_version = out_request->tool_version;
-   record->capability_mask = capability_mask;
-   record->input_hash = input_hash;
-+  record->arg_size = arg_size;
-+  if (arg_size > 0) {
-+    memcpy(record->arg_blob, arg_blob, arg_size);
-+  }
-   record->received = 0;
-   record->next = NULL;
- 
-diff --git a/tools/engine/src/engine_internal.h b/tools/engine/src/engine_internal.h
-index e3ae7d0..321282d 100644
---- a/tools/engine/src/engine_internal.h
-+++ b/tools/engine/src/engine_internal.h
-@@ -188,6 +188,8 @@ typedef struct shoots_provider_request_record {
-   uint32_t tool_version;
-   uint64_t capability_mask;
-   uint64_t input_hash;
-+  uint32_t arg_size;
-+  uint8_t  arg_blob[SHOOTS_PROVIDER_ARG_MAX_BYTES];
-   uint8_t  received;
-   struct shoots_provider_request_record *next;
- } shoots_provider_request_record_t;
-@@ -364,6 +366,12 @@ shoots_error_code_t shoots_provider_receipt_map_terminal_internal(
-   const shoots_provider_receipt_t *receipt,
-   shoots_error_info_t *out_error);
- 
-+shoots_error_code_t shoots_provider_requests_export_internal(
-+  shoots_engine_t *engine,
-+  shoots_provider_request_t **out_requests,
-+  size_t *out_count,
-+  shoots_error_info_t *out_error);
-+
- shoots_error_code_t shoots_session_create_internal(
-   shoots_engine_t *engine,
-   const char *intent_id,
-diff --git a/tools/engine/src/provider_runtime.c b/tools/engine/src/provider_runtime.c
-index 083c67c..270123d 100644
---- a/tools/engine/src/provider_runtime.c
-+++ b/tools/engine/src/provider_runtime.c
-@@ -386,6 +386,86 @@ shoots_error_code_t shoots_provider_runtime_validate_ready(
-   return SHOOTS_OK;
- }
- 
-+shoots_error_code_t shoots_provider_requests_export_internal(
-+  shoots_engine_t *engine,
-+  shoots_provider_request_t **out_requests,
-+  size_t *out_count,
-+  shoots_error_info_t *out_error) {
-+  shoots_error_clear(out_error);
-+  if (out_requests == NULL || out_count == NULL) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "output is null");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  *out_requests = NULL;
-+  *out_count = 0;
-+  if (engine == NULL) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "engine is null");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  shoots_error_code_t engine_status = shoots_validate_engine(engine, out_error);
-+  if (engine_status != SHOOTS_OK) {
-+    return engine_status;
-+  }
-+  size_t pending_count = 0;
-+  shoots_provider_request_record_t *cursor = engine->provider_requests_head;
-+  while (cursor != NULL) {
-+    if (!cursor->received) {
-+      pending_count++;
-+    }
-+    cursor = cursor->next;
-+  }
-+  if (pending_count == 0) {
-+    return SHOOTS_OK;
-+  }
-+  if (pending_count > SIZE_MAX / sizeof(shoots_provider_request_t)) {
-+    shoots_error_set(out_error, SHOOTS_ERR_OUT_OF_MEMORY, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "request export size overflow");
-+    return SHOOTS_ERR_OUT_OF_MEMORY;
-+  }
-+  shoots_provider_request_t *requests =
-+      (shoots_provider_request_t *)shoots_engine_alloc_internal(
-+          engine, pending_count * sizeof(*requests), out_error);
-+  if (requests == NULL) {
-+    return SHOOTS_ERR_OUT_OF_MEMORY;
-+  }
-+  size_t index = 0;
-+  cursor = engine->provider_requests_head;
-+  while (cursor != NULL) {
-+    if (!cursor->received) {
-+      if (cursor->arg_size > SHOOTS_PROVIDER_ARG_MAX_BYTES) {
-+        shoots_engine_alloc_free_internal(engine, requests);
-+        shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                         "request arg size invalid");
-+        return SHOOTS_ERR_INVALID_STATE;
-+      }
-+      shoots_provider_request_t *request = &requests[index];
-+      memset(request, 0, sizeof(*request));
-+      request->session_id = cursor->session_id;
-+      request->plan_id = cursor->plan_id;
-+      request->execution_slot = cursor->execution_slot;
-+      request->request_id = cursor->request_id;
-+      request->provider_id_len = cursor->provider_id_len;
-+      memcpy(request->provider_id, cursor->provider_id, cursor->provider_id_len + 1);
-+      request->tool_id_len = cursor->tool_id_len;
-+      memcpy(request->tool_id, cursor->tool_id, cursor->tool_id_len + 1);
-+      request->tool_version = cursor->tool_version;
-+      request->capability_mask = cursor->capability_mask;
-+      request->input_hash = cursor->input_hash;
-+      request->arg_size = cursor->arg_size;
-+      if (cursor->arg_size > 0) {
-+        memcpy(request->arg_blob, cursor->arg_blob, cursor->arg_size);
-+      }
-+      index++;
-+    }
-+    cursor = cursor->next;
-+  }
-+  *out_requests = requests;
-+  *out_count = index;
-+  return SHOOTS_OK;
-+}
-+
- shoots_error_code_t shoots_provider_descriptor_validate(
-   const shoots_provider_descriptor_t *descriptor,
-   shoots_error_info_t *out_error) {
diff --git a/.ai/patches/patch-2026-01-30-03-26-30.diff b/.ai/patches/patch-2026-01-30-03-26-30.diff
deleted file mode 100644
index ad03900..0000000
--- a/.ai/patches/patch-2026-01-30-03-26-30.diff
+++ /dev/null
@@ -1,626 +0,0 @@
-diff --git a/tools/engine/src/engine.c b/tools/engine/src/engine.c
-index e9b0978..136ffa0 100644
---- a/tools/engine/src/engine.c
-+++ b/tools/engine/src/engine.c
-@@ -1107,6 +1107,208 @@ static uint64_t shoots_request_hash_update(uint64_t hash,
-   return hash;
- }
- 
-+static uint64_t shoots_provider_registry_digest(const shoots_engine_t *engine) {
-+  uint64_t hash = 14695981039346656037ull;
-+  if (engine == NULL) {
-+    return hash;
-+  }
-+  for (size_t index = 0; index < engine->provider_count; index++) {
-+    const shoots_provider_descriptor_t *provider = &engine->providers[index];
-+    hash = shoots_request_hash_update(hash, &provider->provider_id_len,
-+                                      sizeof(provider->provider_id_len));
-+    hash = shoots_request_hash_update(hash, provider->provider_id,
-+                                      provider->provider_id_len);
-+    hash = shoots_request_hash_update(hash, &provider->supported_tool_categories,
-+                                      sizeof(provider->supported_tool_categories));
-+    hash = shoots_request_hash_update(hash, &provider->max_concurrency,
-+                                      sizeof(provider->max_concurrency));
-+    hash = shoots_request_hash_update(hash, &provider->guarantees_mask,
-+                                      sizeof(provider->guarantees_mask));
-+  }
-+  return hash;
-+}
-+
-+static int shoots_provider_request_record_compare(const void *left, const void *right) {
-+  const shoots_provider_request_record_t *first =
-+      *(const shoots_provider_request_record_t *const *)left;
-+  const shoots_provider_request_record_t *second =
-+      *(const shoots_provider_request_record_t *const *)right;
-+  if (first->request_id < second->request_id) {
-+    return -1;
-+  }
-+  if (first->request_id > second->request_id) {
-+    return 1;
-+  }
-+  if (first->session_id < second->session_id) {
-+    return -1;
-+  }
-+  if (first->session_id > second->session_id) {
-+    return 1;
-+  }
-+  if (first->plan_id < second->plan_id) {
-+    return -1;
-+  }
-+  if (first->plan_id > second->plan_id) {
-+    return 1;
-+  }
-+  if (first->execution_slot < second->execution_slot) {
-+    return -1;
-+  }
-+  if (first->execution_slot > second->execution_slot) {
-+    return 1;
-+  }
-+  if (first->provider_id_len < second->provider_id_len) {
-+    return -1;
-+  }
-+  if (first->provider_id_len > second->provider_id_len) {
-+    return 1;
-+  }
-+  if (first->provider_id_len > 0) {
-+    int provider_cmp = memcmp(first->provider_id, second->provider_id,
-+                              first->provider_id_len);
-+    if (provider_cmp != 0) {
-+      return provider_cmp;
-+    }
-+  }
-+  if (first->tool_id_len < second->tool_id_len) {
-+    return -1;
-+  }
-+  if (first->tool_id_len > second->tool_id_len) {
-+    return 1;
-+  }
-+  if (first->tool_id_len > 0) {
-+    int tool_cmp = memcmp(first->tool_id, second->tool_id, first->tool_id_len);
-+    if (tool_cmp != 0) {
-+      return tool_cmp;
-+    }
-+  }
-+  if (first->tool_version < second->tool_version) {
-+    return -1;
-+  }
-+  if (first->tool_version > second->tool_version) {
-+    return 1;
-+  }
-+  if (first->capability_mask < second->capability_mask) {
-+    return -1;
-+  }
-+  if (first->capability_mask > second->capability_mask) {
-+    return 1;
-+  }
-+  if (first->input_hash < second->input_hash) {
-+    return -1;
-+  }
-+  if (first->input_hash > second->input_hash) {
-+    return 1;
-+  }
-+  if (first->arg_size < second->arg_size) {
-+    return -1;
-+  }
-+  if (first->arg_size > second->arg_size) {
-+    return 1;
-+  }
-+  if (first->arg_size > 0) {
-+    int arg_cmp = memcmp(first->arg_blob, second->arg_blob, first->arg_size);
-+    if (arg_cmp != 0) {
-+      return arg_cmp;
-+    }
-+  }
-+  if (first->received < second->received) {
-+    return -1;
-+  }
-+  if (first->received > second->received) {
-+    return 1;
-+  }
-+  return 0;
-+}
-+
-+static int shoots_result_is_provider_terminal(const shoots_result_record_t *result) {
-+  const char *prefix = "provider_request=";
-+  size_t prefix_len = strlen(prefix);
-+  if (result == NULL || result->command_id == NULL) {
-+    return 0;
-+  }
-+  return strncmp(result->command_id, prefix, prefix_len) == 0;
-+}
-+
-+static int shoots_provider_result_compare(const void *left, const void *right) {
-+  const shoots_result_record_t *first = *(const shoots_result_record_t *const *)left;
-+  const shoots_result_record_t *second = *(const shoots_result_record_t *const *)right;
-+  if (first->session_id < second->session_id) {
-+    return -1;
-+  }
-+  if (first->session_id > second->session_id) {
-+    return 1;
-+  }
-+  if (first->execution_slot < second->execution_slot) {
-+    return -1;
-+  }
-+  if (first->execution_slot > second->execution_slot) {
-+    return 1;
-+  }
-+  if (first->command_id == NULL && second->command_id != NULL) {
-+    return -1;
-+  }
-+  if (first->command_id != NULL && second->command_id == NULL) {
-+    return 1;
-+  }
-+  if (first->command_id != NULL && second->command_id != NULL) {
-+    int command_cmp = strcmp(first->command_id, second->command_id);
-+    if (command_cmp != 0) {
-+      return command_cmp;
-+    }
-+  }
-+  if (first->ledger_entry_id < second->ledger_entry_id) {
-+    return -1;
-+  }
-+  if (first->ledger_entry_id > second->ledger_entry_id) {
-+    return 1;
-+  }
-+  if (first->status < second->status) {
-+    return -1;
-+  }
-+  if (first->status > second->status) {
-+    return 1;
-+  }
-+  if (first->payload_len < second->payload_len) {
-+    return -1;
-+  }
-+  if (first->payload_len > second->payload_len) {
-+    return 1;
-+  }
-+  if (first->payload != NULL && second->payload != NULL && first->payload_len > 0) {
-+    int payload_cmp = memcmp(first->payload, second->payload, first->payload_len);
-+    if (payload_cmp != 0) {
-+      return payload_cmp;
-+    }
-+  }
-+  return 0;
-+}
-+
-+static shoots_error_code_t shoots_snapshot_add_size(
-+  size_t *total,
-+  size_t add,
-+  shoots_error_info_t *out_error) {
-+  if (add > SIZE_MAX - *total) {
-+    shoots_error_set(out_error, SHOOTS_ERR_OUT_OF_MEMORY, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "snapshot size overflow");
-+    return SHOOTS_ERR_OUT_OF_MEMORY;
-+  }
-+  *total += add;
-+  return SHOOTS_OK;
-+}
-+
-+static void shoots_snapshot_write_hex(char *buffer,
-+                                      size_t offset,
-+                                      const uint8_t *bytes,
-+                                      size_t length) {
-+  static const char hex_digits[] = "0123456789abcdef";
-+  for (size_t index = 0; index < length; index++) {
-+    uint8_t value = bytes[index];
-+    buffer[offset + index * 2] = hex_digits[(value >> 4) & 0x0f];
-+    buffer[offset + index * 2 + 1] = hex_digits[value & 0x0f];
-+  }
-+}
-+
- static uint64_t shoots_provider_request_id(
-   uint64_t session_id,
-   uint64_t plan_id,
-@@ -2498,6 +2700,363 @@ shoots_error_code_t shoots_ledger_query_substring_internal(
-   return SHOOTS_OK;
- }
- 
-+shoots_error_code_t shoots_provider_snapshot_export_internal(
-+  shoots_engine_t *engine,
-+  char **out_snapshot,
-+  size_t *out_length,
-+  shoots_error_info_t *out_error) {
-+  shoots_error_clear(out_error);
-+  if (out_snapshot == NULL || out_length == NULL) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "output is null");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  *out_snapshot = NULL;
-+  *out_length = 0;
-+  shoots_error_code_t engine_status = shoots_validate_engine(engine, out_error);
-+  if (engine_status != SHOOTS_OK) {
-+    return engine_status;
-+  }
-+  uint64_t registry_digest = shoots_provider_registry_digest(engine);
-+
-+  size_t request_count = 0;
-+  shoots_provider_request_record_t *request_cursor = engine->provider_requests_head;
-+  while (request_cursor != NULL) {
-+    request_count++;
-+    request_cursor = request_cursor->next;
-+  }
-+  shoots_provider_request_record_t **request_records = NULL;
-+  if (request_count > 0) {
-+    request_records = (shoots_provider_request_record_t **)shoots_engine_alloc_internal(
-+        engine, request_count * sizeof(*request_records), out_error);
-+    if (request_records == NULL) {
-+      return SHOOTS_ERR_OUT_OF_MEMORY;
-+    }
-+    size_t index = 0;
-+    request_cursor = engine->provider_requests_head;
-+    while (request_cursor != NULL) {
-+      request_records[index] = request_cursor;
-+      index++;
-+      request_cursor = request_cursor->next;
-+    }
-+    qsort(request_records, request_count, sizeof(*request_records),
-+          shoots_provider_request_record_compare);
-+  }
-+
-+  size_t result_count = 0;
-+  shoots_result_record_t *result_cursor = engine->results_head;
-+  while (result_cursor != NULL) {
-+    if (shoots_result_is_provider_terminal(result_cursor)) {
-+      result_count++;
-+    }
-+    result_cursor = result_cursor->next;
-+  }
-+  shoots_result_record_t **result_records = NULL;
-+  if (result_count > 0) {
-+    result_records = (shoots_result_record_t **)shoots_engine_alloc_internal(
-+        engine, result_count * sizeof(*result_records), out_error);
-+    if (result_records == NULL) {
-+      shoots_engine_alloc_free_internal(engine, request_records);
-+      return SHOOTS_ERR_OUT_OF_MEMORY;
-+    }
-+    size_t index = 0;
-+    result_cursor = engine->results_head;
-+    while (result_cursor != NULL) {
-+      if (shoots_result_is_provider_terminal(result_cursor)) {
-+        result_records[index] = result_cursor;
-+        index++;
-+      }
-+      result_cursor = result_cursor->next;
-+    }
-+    qsort(result_records, result_count, sizeof(*result_records),
-+          shoots_provider_result_compare);
-+  }
-+
-+  size_t total_len = 0;
-+  int header_len = snprintf(NULL, 0,
-+                            "provider_registry count=%zu digest=0x%016" PRIx64 "\n",
-+                            engine->provider_count, registry_digest);
-+  if (header_len < 0) {
-+    shoots_engine_alloc_free_internal(engine, request_records);
-+    shoots_engine_alloc_free_internal(engine, result_records);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "snapshot format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  shoots_error_code_t size_status =
-+      shoots_snapshot_add_size(&total_len, (size_t)header_len, out_error);
-+  if (size_status != SHOOTS_OK) {
-+    shoots_engine_alloc_free_internal(engine, request_records);
-+    shoots_engine_alloc_free_internal(engine, result_records);
-+    return size_status;
-+  }
-+  for (size_t index = 0; index < engine->provider_count; index++) {
-+    const shoots_provider_descriptor_t *provider = &engine->providers[index];
-+    int line_len = snprintf(NULL, 0,
-+                            "provider[%zu] provider_id=%.*s categories=0x%08" PRIx32
-+                            " max_concurrency=%" PRIu32 " guarantees=0x%08" PRIx32 "\n",
-+                            index,
-+                            (int)provider->provider_id_len,
-+                            provider->provider_id,
-+                            provider->supported_tool_categories,
-+                            provider->max_concurrency,
-+                            provider->guarantees_mask);
-+    if (line_len < 0) {
-+      shoots_engine_alloc_free_internal(engine, request_records);
-+      shoots_engine_alloc_free_internal(engine, result_records);
-+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                       "snapshot format failed");
-+      return SHOOTS_ERR_INVALID_STATE;
-+    }
-+    size_status = shoots_snapshot_add_size(&total_len, (size_t)line_len, out_error);
-+    if (size_status != SHOOTS_OK) {
-+      shoots_engine_alloc_free_internal(engine, request_records);
-+      shoots_engine_alloc_free_internal(engine, result_records);
-+      return size_status;
-+    }
-+  }
-+  int request_header_len = snprintf(NULL, 0, "provider_requests count=%zu\n",
-+                                    request_count);
-+  if (request_header_len < 0) {
-+    shoots_engine_alloc_free_internal(engine, request_records);
-+    shoots_engine_alloc_free_internal(engine, result_records);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "snapshot format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  size_status = shoots_snapshot_add_size(&total_len,
-+                                         (size_t)request_header_len,
-+                                         out_error);
-+  if (size_status != SHOOTS_OK) {
-+    shoots_engine_alloc_free_internal(engine, request_records);
-+    shoots_engine_alloc_free_internal(engine, result_records);
-+    return size_status;
-+  }
-+  for (size_t index = 0; index < request_count; index++) {
-+    const shoots_provider_request_record_t *record = request_records[index];
-+    int prefix_len = snprintf(NULL, 0,
-+                              "request[%zu] session_id=%" PRIu64
-+                              " plan_id=%" PRIu64 " execution_slot=%" PRIu64
-+                              " request_id=0x%016" PRIx64
-+                              " provider_id=%.*s tool_id=%.*s tool_version=%" PRIu32
-+                              " capability_mask=0x%016" PRIx64
-+                              " input_hash=0x%016" PRIx64
-+                              " arg_size=%" PRIu32 " arg_hex=",
-+                              index,
-+                              record->session_id,
-+                              record->plan_id,
-+                              record->execution_slot,
-+                              record->request_id,
-+                              (int)record->provider_id_len,
-+                              record->provider_id,
-+                              (int)record->tool_id_len,
-+                              record->tool_id,
-+                              record->tool_version,
-+                              record->capability_mask,
-+                              record->input_hash,
-+                              record->arg_size);
-+    if (prefix_len < 0) {
-+      shoots_engine_alloc_free_internal(engine, request_records);
-+      shoots_engine_alloc_free_internal(engine, result_records);
-+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                       "snapshot format failed");
-+      return SHOOTS_ERR_INVALID_STATE;
-+    }
-+    size_t line_len = (size_t)prefix_len + (size_t)record->arg_size * 2u + 1u;
-+    size_status = shoots_snapshot_add_size(&total_len, line_len, out_error);
-+    if (size_status != SHOOTS_OK) {
-+      shoots_engine_alloc_free_internal(engine, request_records);
-+      shoots_engine_alloc_free_internal(engine, result_records);
-+      return size_status;
-+    }
-+  }
-+  int result_header_len = snprintf(NULL, 0, "provider_results count=%zu\n",
-+                                   result_count);
-+  if (result_header_len < 0) {
-+    shoots_engine_alloc_free_internal(engine, request_records);
-+    shoots_engine_alloc_free_internal(engine, result_records);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "snapshot format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  size_status = shoots_snapshot_add_size(&total_len, (size_t)result_header_len, out_error);
-+  if (size_status != SHOOTS_OK) {
-+    shoots_engine_alloc_free_internal(engine, request_records);
-+    shoots_engine_alloc_free_internal(engine, result_records);
-+    return size_status;
-+  }
-+  for (size_t index = 0; index < result_count; index++) {
-+    const shoots_result_record_t *result = result_records[index];
-+    const char *command_id = result->command_id != NULL ? result->command_id : "";
-+    const char *payload = result->payload != NULL ? result->payload : "";
-+    int line_len = snprintf(NULL, 0,
-+                            "result[%zu] session_id=%" PRIu64
-+                            " execution_slot=%" PRIu64
-+                            " ledger_entry_id=%" PRIu64
-+                            " command_id=%s status=%d payload=%s\n",
-+                            index,
-+                            result->session_id,
-+                            result->execution_slot,
-+                            result->ledger_entry_id,
-+                            command_id,
-+                            result->status,
-+                            payload);
-+    if (line_len < 0) {
-+      shoots_engine_alloc_free_internal(engine, request_records);
-+      shoots_engine_alloc_free_internal(engine, result_records);
-+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                       "snapshot format failed");
-+      return SHOOTS_ERR_INVALID_STATE;
-+    }
-+    size_status = shoots_snapshot_add_size(&total_len, (size_t)line_len, out_error);
-+    if (size_status != SHOOTS_OK) {
-+      shoots_engine_alloc_free_internal(engine, request_records);
-+      shoots_engine_alloc_free_internal(engine, result_records);
-+      return size_status;
-+    }
-+  }
-+  if (total_len > SIZE_MAX - 1) {
-+    shoots_engine_alloc_free_internal(engine, request_records);
-+    shoots_engine_alloc_free_internal(engine, result_records);
-+    shoots_error_set(out_error, SHOOTS_ERR_OUT_OF_MEMORY, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "snapshot size overflow");
-+    return SHOOTS_ERR_OUT_OF_MEMORY;
-+  }
-+  char *buffer = (char *)shoots_engine_alloc_internal(engine, total_len + 1, out_error);
-+  if (buffer == NULL) {
-+    shoots_engine_alloc_free_internal(engine, request_records);
-+    shoots_engine_alloc_free_internal(engine, result_records);
-+    return SHOOTS_ERR_OUT_OF_MEMORY;
-+  }
-+  size_t offset = 0;
-+  int written = snprintf(buffer + offset, total_len + 1 - offset,
-+                         "provider_registry count=%zu digest=0x%016" PRIx64 "\n",
-+                         engine->provider_count, registry_digest);
-+  if (written < 0) {
-+    shoots_engine_alloc_free_internal(engine, request_records);
-+    shoots_engine_alloc_free_internal(engine, result_records);
-+    shoots_engine_alloc_free_internal(engine, buffer);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "snapshot format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  offset += (size_t)written;
-+  for (size_t index = 0; index < engine->provider_count; index++) {
-+    const shoots_provider_descriptor_t *provider = &engine->providers[index];
-+    written = snprintf(buffer + offset, total_len + 1 - offset,
-+                       "provider[%zu] provider_id=%.*s categories=0x%08" PRIx32
-+                       " max_concurrency=%" PRIu32 " guarantees=0x%08" PRIx32 "\n",
-+                       index,
-+                       (int)provider->provider_id_len,
-+                       provider->provider_id,
-+                       provider->supported_tool_categories,
-+                       provider->max_concurrency,
-+                       provider->guarantees_mask);
-+    if (written < 0) {
-+      shoots_engine_alloc_free_internal(engine, request_records);
-+      shoots_engine_alloc_free_internal(engine, result_records);
-+      shoots_engine_alloc_free_internal(engine, buffer);
-+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                       "snapshot format failed");
-+      return SHOOTS_ERR_INVALID_STATE;
-+    }
-+    offset += (size_t)written;
-+  }
-+  written = snprintf(buffer + offset, total_len + 1 - offset,
-+                     "provider_requests count=%zu\n", request_count);
-+  if (written < 0) {
-+    shoots_engine_alloc_free_internal(engine, request_records);
-+    shoots_engine_alloc_free_internal(engine, result_records);
-+    shoots_engine_alloc_free_internal(engine, buffer);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "snapshot format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  offset += (size_t)written;
-+  for (size_t index = 0; index < request_count; index++) {
-+    const shoots_provider_request_record_t *record = request_records[index];
-+    written = snprintf(buffer + offset, total_len + 1 - offset,
-+                       "request[%zu] session_id=%" PRIu64
-+                       " plan_id=%" PRIu64 " execution_slot=%" PRIu64
-+                       " request_id=0x%016" PRIx64
-+                       " provider_id=%.*s tool_id=%.*s tool_version=%" PRIu32
-+                       " capability_mask=0x%016" PRIx64
-+                       " input_hash=0x%016" PRIx64
-+                       " arg_size=%" PRIu32 " arg_hex=",
-+                       index,
-+                       record->session_id,
-+                       record->plan_id,
-+                       record->execution_slot,
-+                       record->request_id,
-+                       (int)record->provider_id_len,
-+                       record->provider_id,
-+                       (int)record->tool_id_len,
-+                       record->tool_id,
-+                       record->tool_version,
-+                       record->capability_mask,
-+                       record->input_hash,
-+                       record->arg_size);
-+    if (written < 0) {
-+      shoots_engine_alloc_free_internal(engine, request_records);
-+      shoots_engine_alloc_free_internal(engine, result_records);
-+      shoots_engine_alloc_free_internal(engine, buffer);
-+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                       "snapshot format failed");
-+      return SHOOTS_ERR_INVALID_STATE;
-+    }
-+    offset += (size_t)written;
-+    if (record->arg_size > 0) {
-+      shoots_snapshot_write_hex(buffer, offset, record->arg_blob, record->arg_size);
-+      offset += (size_t)record->arg_size * 2u;
-+    }
-+    buffer[offset] = '\n';
-+    offset += 1;
-+  }
-+  written = snprintf(buffer + offset, total_len + 1 - offset,
-+                     "provider_results count=%zu\n", result_count);
-+  if (written < 0) {
-+    shoots_engine_alloc_free_internal(engine, request_records);
-+    shoots_engine_alloc_free_internal(engine, result_records);
-+    shoots_engine_alloc_free_internal(engine, buffer);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "snapshot format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  offset += (size_t)written;
-+  for (size_t index = 0; index < result_count; index++) {
-+    const shoots_result_record_t *result = result_records[index];
-+    const char *command_id = result->command_id != NULL ? result->command_id : "";
-+    const char *payload = result->payload != NULL ? result->payload : "";
-+    written = snprintf(buffer + offset, total_len + 1 - offset,
-+                       "result[%zu] session_id=%" PRIu64
-+                       " execution_slot=%" PRIu64
-+                       " ledger_entry_id=%" PRIu64
-+                       " command_id=%s status=%d payload=%s\n",
-+                       index,
-+                       result->session_id,
-+                       result->execution_slot,
-+                       result->ledger_entry_id,
-+                       command_id,
-+                       result->status,
-+                       payload);
-+    if (written < 0) {
-+      shoots_engine_alloc_free_internal(engine, request_records);
-+      shoots_engine_alloc_free_internal(engine, result_records);
-+      shoots_engine_alloc_free_internal(engine, buffer);
-+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                       "snapshot format failed");
-+      return SHOOTS_ERR_INVALID_STATE;
-+    }
-+    offset += (size_t)written;
-+  }
-+  buffer[offset] = '\0';
-+  shoots_engine_alloc_free_internal(engine, request_records);
-+  shoots_engine_alloc_free_internal(engine, result_records);
-+  *out_snapshot = buffer;
-+  *out_length = total_len;
-+  return SHOOTS_OK;
-+}
-+
- shoots_error_code_t shoots_command_append_internal(
-   shoots_engine_t *engine,
-   shoots_session_t *session,
-diff --git a/tools/engine/src/engine_internal.h b/tools/engine/src/engine_internal.h
-index eba2e49..dd92981 100644
---- a/tools/engine/src/engine_internal.h
-+++ b/tools/engine/src/engine_internal.h
-@@ -452,6 +452,12 @@ shoots_error_code_t shoots_ledger_query_substring_internal(
-   size_t *out_count,
-   shoots_error_info_t *out_error);
- 
-+shoots_error_code_t shoots_provider_snapshot_export_internal(
-+  shoots_engine_t *engine,
-+  char **out_snapshot,
-+  size_t *out_length,
-+  shoots_error_info_t *out_error);
-+
- shoots_error_code_t shoots_command_append_internal(
-   shoots_engine_t *engine,
-   shoots_session_t *session,
-diff --git a/tools/engine/src/ledger.c b/tools/engine/src/ledger.c
-index b99fb7d..e67e1bf 100644
---- a/tools/engine/src/ledger.c
-+++ b/tools/engine/src/ledger.c
-@@ -17,3 +17,12 @@ shoots_error_code_t ledger_query_type(
-   shoots_error_info_t *out_error) {
-   return shoots_ledger_query_type_internal(engine, type, out_entries, out_count, out_error);
- }
-+
-+shoots_error_code_t ledger_provider_snapshot(
-+  shoots_engine_t *engine,
-+  char **out_snapshot,
-+  size_t *out_length,
-+  shoots_error_info_t *out_error) {
-+  return shoots_provider_snapshot_export_internal(
-+      engine, out_snapshot, out_length, out_error);
-+}
-diff --git a/tools/engine/src/ledger.h b/tools/engine/src/ledger.h
-index 4ebd836..dc39660 100644
---- a/tools/engine/src/ledger.h
-+++ b/tools/engine/src/ledger.h
-@@ -17,4 +17,10 @@ shoots_error_code_t ledger_query_type(
-   size_t *out_count,
-   shoots_error_info_t *out_error);
- 
-+shoots_error_code_t ledger_provider_snapshot(
-+  shoots_engine_t *engine,
-+  char **out_snapshot,
-+  size_t *out_length,
-+  shoots_error_info_t *out_error);
-+
- #endif
diff --git a/.ai/patches/patch-2026-01-30-03-35-04.diff b/.ai/patches/patch-2026-01-30-03-35-04.diff
deleted file mode 100644
index efbc5e5..0000000
--- a/.ai/patches/patch-2026-01-30-03-35-04.diff
+++ /dev/null
@@ -1,307 +0,0 @@
-diff --git a/tools/engine/src/engine.c b/tools/engine/src/engine.c
-index 136ffa0..a200814 100644
---- a/tools/engine/src/engine.c
-+++ b/tools/engine/src/engine.c
-@@ -69,6 +69,12 @@ static shoots_error_code_t shoots_invariant_violation(shoots_engine_t *engine,
-   return SHOOTS_ERR_INVALID_STATE;
- }
- 
-+shoots_error_code_t shoots_invariant_violation_internal(shoots_engine_t *engine,
-+                                                        const char *message,
-+                                                        shoots_error_info_t *out_error) {
-+  return shoots_invariant_violation(engine, message, out_error);
-+}
-+
- static void shoots_assert_invariants(const shoots_engine_t *engine) {
- #ifndef NDEBUG
-   if (engine == NULL) {
-@@ -1128,6 +1134,18 @@ static uint64_t shoots_provider_registry_digest(const shoots_engine_t *engine) {
-   return hash;
- }
- 
-+static void shoots_provider_maybe_seal(shoots_engine_t *engine) {
-+  if (engine == NULL) {
-+    return;
-+  }
-+  if (engine->provider_system_sealed) {
-+    return;
-+  }
-+  if (engine->providers_locked && engine->provider_snapshot_exported) {
-+    engine->provider_system_sealed = 1;
-+  }
-+}
-+
- static int shoots_provider_request_record_compare(const void *left, const void *right) {
-   const shoots_provider_request_record_t *first =
-       *(const shoots_provider_request_record_t *const *)left;
-@@ -1956,6 +1974,8 @@ shoots_error_code_t shoots_engine_create(const shoots_config_t *config,
-   engine->provider_runtime = NULL;
-   engine->provider_count = 0;
-   engine->providers_locked = 0;
-+  engine->provider_snapshot_exported = 0;
-+  engine->provider_system_sealed = 0;
-   engine->models_head = NULL;
-   engine->models_tail = NULL;
-   engine->sessions_head = NULL;
-@@ -2717,6 +2737,8 @@ shoots_error_code_t shoots_provider_snapshot_export_internal(
-   if (engine_status != SHOOTS_OK) {
-     return engine_status;
-   }
-+  engine->provider_snapshot_exported = 1;
-+  shoots_provider_maybe_seal(engine);
-   uint64_t registry_digest = shoots_provider_registry_digest(engine);
- 
-   size_t request_count = 0;
-@@ -3057,6 +3079,29 @@ shoots_error_code_t shoots_provider_snapshot_export_internal(
-   return SHOOTS_OK;
- }
- 
-+uint8_t shoots_engine_provider_ready(const shoots_engine_t *engine) {
-+  if (engine == NULL) {
-+    return 0;
-+  }
-+  if (engine->state != SHOOTS_ENGINE_STATE_INITIALIZED) {
-+    return 0;
-+  }
-+  if (!engine->providers_locked || !engine->provider_system_sealed) {
-+    return 0;
-+  }
-+  if (engine->provider_count == 0) {
-+    return 0;
-+  }
-+  shoots_provider_request_record_t *cursor = engine->provider_requests_head;
-+  while (cursor != NULL) {
-+    if (!cursor->received) {
-+      return 0;
-+    }
-+    cursor = cursor->next;
-+  }
-+  return 1;
-+}
-+
- shoots_error_code_t shoots_command_append_internal(
-   shoots_engine_t *engine,
-   shoots_session_t *session,
-diff --git a/tools/engine/src/engine_internal.h b/tools/engine/src/engine_internal.h
-index dd92981..f0cb16e 100644
---- a/tools/engine/src/engine_internal.h
-+++ b/tools/engine/src/engine_internal.h
-@@ -277,6 +277,8 @@ struct shoots_engine {
-   shoots_provider_descriptor_t providers[SHOOTS_ENGINE_MAX_PROVIDERS];
-   size_t provider_count;
-   uint8_t providers_locked;
-+  uint8_t provider_snapshot_exported;
-+  uint8_t provider_system_sealed;
- 
-   struct shoots_model   *models_head;
-   struct shoots_model   *models_tail;
-@@ -452,12 +454,19 @@ shoots_error_code_t shoots_ledger_query_substring_internal(
-   size_t *out_count,
-   shoots_error_info_t *out_error);
- 
-+shoots_error_code_t shoots_invariant_violation_internal(
-+  shoots_engine_t *engine,
-+  const char *message,
-+  shoots_error_info_t *out_error);
-+
- shoots_error_code_t shoots_provider_snapshot_export_internal(
-   shoots_engine_t *engine,
-   char **out_snapshot,
-   size_t *out_length,
-   shoots_error_info_t *out_error);
- 
-+uint8_t shoots_engine_provider_ready(const shoots_engine_t *engine);
-+
- shoots_error_code_t shoots_command_append_internal(
-   shoots_engine_t *engine,
-   shoots_session_t *session,
-diff --git a/tools/engine/src/provider_runtime.c b/tools/engine/src/provider_runtime.c
-index c71be89..568fe38 100644
---- a/tools/engine/src/provider_runtime.c
-+++ b/tools/engine/src/provider_runtime.c
-@@ -111,6 +111,23 @@ static void shoots_provider_format_id_value(const char *provider_id,
-   }
- }
- 
-+static int shoots_provider_terminal_seen(const shoots_engine_t *engine) {
-+  if (engine == NULL) {
-+    return 0;
-+  }
-+  const char *prefix = "provider_terminal ";
-+  size_t prefix_len = strlen(prefix);
-+  shoots_ledger_entry_t *cursor = engine->ledger_head;
-+  while (cursor != NULL) {
-+    if (cursor->payload != NULL &&
-+        strncmp(cursor->payload, prefix, prefix_len) == 0) {
-+      return 1;
-+    }
-+    cursor = cursor->next;
-+  }
-+  return 0;
-+}
-+
- static int shoots_provider_request_compare(const void *left, const void *right) {
-   const shoots_provider_request_t *first =
-       (const shoots_provider_request_t *)left;
-@@ -634,6 +651,18 @@ shoots_error_code_t shoots_provider_register_internal(
-   }
-   char provider_id[SHOOTS_PROVIDER_ID_MAX];
-   shoots_provider_format_id(descriptor, provider_id, sizeof(provider_id));
-+  if (engine->provider_system_sealed) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "provider system sealed");
-+    shoots_provider_emit_register_entry(engine, provider_id, "REJECT", "sealed", NULL);
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  if (shoots_provider_terminal_seen(engine)) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "provider lifecycle sealed");
-+    shoots_provider_emit_register_entry(engine, provider_id, "REJECT", "terminal_guard", NULL);
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-   shoots_error_code_t validation_status =
-       shoots_provider_descriptor_validate(descriptor, out_error);
-   if (validation_status != SHOOTS_OK) {
-@@ -686,6 +715,18 @@ shoots_error_code_t shoots_provider_registry_lock_internal(
-                      "engine is null");
-     return SHOOTS_ERR_INVALID_ARGUMENT;
-   }
-+  if (engine->provider_system_sealed) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "provider system sealed");
-+    shoots_provider_emit_lock_entry(engine, "REJECT", NULL);
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  if (shoots_provider_terminal_seen(engine)) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "provider lifecycle sealed");
-+    shoots_provider_emit_lock_entry(engine, "REJECT", NULL);
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-   if (engine->providers_locked) {
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-                      "provider registry already locked");
-@@ -693,6 +734,9 @@ shoots_error_code_t shoots_provider_registry_lock_internal(
-     return SHOOTS_ERR_INVALID_STATE;
-   }
-   engine->providers_locked = 1;
-+  if (engine->provider_snapshot_exported) {
-+    engine->provider_system_sealed = 1;
-+  }
-   return shoots_provider_emit_lock_entry(engine, "ACCEPT", out_error);
- }
- 
-@@ -709,6 +753,19 @@ shoots_error_code_t shoots_provider_unregister_internal(
-   char provider_id_value[SHOOTS_PROVIDER_ID_MAX];
-   shoots_provider_format_id_value(provider_id, provider_id_value,
-                                   sizeof(provider_id_value));
-+  if (engine->provider_system_sealed) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "provider system sealed");
-+    shoots_provider_emit_unregister_entry(engine, provider_id_value, "REJECT", "sealed", NULL);
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  if (shoots_provider_terminal_seen(engine)) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "provider lifecycle sealed");
-+    shoots_provider_emit_unregister_entry(engine, provider_id_value, "REJECT",
-+                                          "terminal_guard", NULL);
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-   if (engine->providers_locked) {
-     shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-                      "provider registry locked");
-diff --git a/tools/engine/src/selfcheck.c b/tools/engine/src/selfcheck.c
-index eb144a4..39691e2 100644
---- a/tools/engine/src/selfcheck.c
-+++ b/tools/engine/src/selfcheck.c
-@@ -1,8 +1,8 @@
- #include "engine_internal.h"
- 
-+#include <string.h>
- #ifndef NDEBUG
- #include <assert.h>
--#include <string.h>
- #endif
- 
- static uint64_t selfcheck_hash_tool_descriptor(
-@@ -67,11 +67,11 @@ static int selfcheck_reason_code_valid(const char *code_text) {
- }
- 
- void selfcheck_run(shoots_engine_t *engine) {
--#ifndef NDEBUG
-   if (engine == NULL) {
-     return;
-   }
- 
-+#ifndef NDEBUG
-   shoots_tool_record_t *tool_cursor = engine->tools_head;
-   while (tool_cursor != NULL) {
-     assert(tool_cursor->tool_id != NULL);
-@@ -193,6 +193,24 @@ void selfcheck_run(shoots_engine_t *engine) {
-     }
-     provider_request = provider_request->next;
-   }
-+  int terminal_seen = 0;
-+  shoots_ledger_entry_t *ledger_guard = engine->ledger_head;
-+  while (ledger_guard != NULL) {
-+    if (ledger_guard->payload != NULL &&
-+        strncmp(ledger_guard->payload, "provider_terminal ", strlen("provider_terminal ")) == 0) {
-+      terminal_seen = 1;
-+    } else if (terminal_seen && ledger_guard->payload != NULL) {
-+      if (strncmp(ledger_guard->payload, "provider_register ",
-+                  strlen("provider_register ")) == 0 ||
-+          strncmp(ledger_guard->payload, "provider_unregister ",
-+                  strlen("provider_unregister ")) == 0 ||
-+          strncmp(ledger_guard->payload, "provider_lock ",
-+                  strlen("provider_lock ")) == 0) {
-+        assert(0 && "provider drift guard violated");
-+      }
-+    }
-+    ledger_guard = ledger_guard->next;
-+  }
- 
-   shoots_command_record_t *command = engine->commands_head;
-   while (command != NULL) {
-@@ -294,7 +312,40 @@ void selfcheck_run(shoots_engine_t *engine) {
-     }
-     ledger = ledger->next;
-   }
-+#endif
-+  char *snapshot_first = NULL;
-+  char *snapshot_second = NULL;
-+  size_t snapshot_first_len = 0;
-+  size_t snapshot_second_len = 0;
-+  shoots_error_info_t snapshot_error;
-+  shoots_error_code_t first_status =
-+      shoots_provider_snapshot_export_internal(engine, &snapshot_first,
-+                                                &snapshot_first_len,
-+                                                &snapshot_error);
-+  shoots_error_code_t second_status =
-+      shoots_provider_snapshot_export_internal(engine, &snapshot_second,
-+                                                &snapshot_second_len,
-+                                                &snapshot_error);
-+#ifndef NDEBUG
-+  assert(first_status == SHOOTS_OK);
-+  assert(second_status == SHOOTS_OK);
-+  assert(snapshot_first_len == snapshot_second_len);
-+  if (snapshot_first_len > 0) {
-+    assert(memcmp(snapshot_first, snapshot_second, snapshot_first_len) == 0);
-+  }
- #else
--  (void)engine;
-+  if (first_status != SHOOTS_OK || second_status != SHOOTS_OK ||
-+      snapshot_first_len != snapshot_second_len ||
-+      (snapshot_first_len > 0 &&
-+       memcmp(snapshot_first, snapshot_second, snapshot_first_len) != 0)) {
-+    shoots_invariant_violation_internal(engine, "provider snapshot unstable",
-+                                        &snapshot_error);
-+  }
- #endif
-+  if (snapshot_first != NULL) {
-+    shoots_engine_alloc_free_internal(engine, snapshot_first);
-+  }
-+  if (snapshot_second != NULL) {
-+    shoots_engine_alloc_free_internal(engine, snapshot_second);
-+  }
- }
diff --git a/.ai/patches/patch-2026-01-30-03-42-12.diff b/.ai/patches/patch-2026-01-30-03-42-12.diff
deleted file mode 100644
index e7a74e5..0000000
--- a/.ai/patches/patch-2026-01-30-03-42-12.diff
+++ /dev/null
@@ -1,941 +0,0 @@
-diff --git a/tools/engine/src/engine.c b/tools/engine/src/engine.c
-index a200814..b22ae29 100644
---- a/tools/engine/src/engine.c
-+++ b/tools/engine/src/engine.c
-@@ -1146,83 +1146,443 @@ static void shoots_provider_maybe_seal(shoots_engine_t *engine) {
-   }
- }
- 
--static int shoots_provider_request_record_compare(const void *left, const void *right) {
--  const shoots_provider_request_record_t *first =
--      *(const shoots_provider_request_record_t *const *)left;
--  const shoots_provider_request_record_t *second =
--      *(const shoots_provider_request_record_t *const *)right;
--  if (first->request_id < second->request_id) {
--    return -1;
--  }
--  if (first->request_id > second->request_id) {
--    return 1;
--  }
--  if (first->session_id < second->session_id) {
--    return -1;
-+static shoots_error_code_t shoots_provider_snapshot_build(
-+  const shoots_engine_t *engine,
-+  char **out_snapshot,
-+  size_t *out_length,
-+  shoots_error_info_t *out_error) {
-+  shoots_error_clear(out_error);
-+  if (out_snapshot == NULL || out_length == NULL) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "output is null");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-   }
--  if (first->session_id > second->session_id) {
--    return 1;
-+  *out_snapshot = NULL;
-+  *out_length = 0;
-+  shoots_error_code_t engine_status =
-+      shoots_validate_engine((shoots_engine_t *)engine, out_error);
-+  if (engine_status != SHOOTS_OK) {
-+    return engine_status;
-   }
--  if (first->plan_id < second->plan_id) {
--    return -1;
-+  uint64_t registry_digest = shoots_provider_registry_digest(engine);
-+
-+  size_t request_count = 0;
-+  shoots_provider_request_record_t *request_cursor = engine->provider_requests_head;
-+  while (request_cursor != NULL) {
-+    request_count++;
-+    request_cursor = request_cursor->next;
-   }
--  if (first->plan_id > second->plan_id) {
--    return 1;
-+  shoots_provider_request_record_t **request_records = NULL;
-+  if (request_count > 0) {
-+    request_records = (shoots_provider_request_record_t **)shoots_engine_alloc_internal(
-+        (shoots_engine_t *)engine, request_count * sizeof(*request_records), out_error);
-+    if (request_records == NULL) {
-+      return SHOOTS_ERR_OUT_OF_MEMORY;
-+    }
-+    size_t index = 0;
-+    request_cursor = engine->provider_requests_head;
-+    while (request_cursor != NULL) {
-+      request_records[index] = request_cursor;
-+      index++;
-+      request_cursor = request_cursor->next;
-+    }
-+    qsort(request_records, request_count, sizeof(*request_records),
-+          shoots_provider_request_record_compare);
-   }
--  if (first->execution_slot < second->execution_slot) {
--    return -1;
-+
-+  size_t result_count = 0;
-+  shoots_result_record_t *result_cursor = engine->results_head;
-+  while (result_cursor != NULL) {
-+    if (shoots_result_is_provider_terminal(result_cursor)) {
-+      result_count++;
-+    }
-+    result_cursor = result_cursor->next;
-   }
--  if (first->execution_slot > second->execution_slot) {
--    return 1;
-+  shoots_result_record_t **result_records = NULL;
-+  if (result_count > 0) {
-+    result_records = (shoots_result_record_t **)shoots_engine_alloc_internal(
-+        (shoots_engine_t *)engine, result_count * sizeof(*result_records), out_error);
-+    if (result_records == NULL) {
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+      return SHOOTS_ERR_OUT_OF_MEMORY;
-+    }
-+    size_t index = 0;
-+    result_cursor = engine->results_head;
-+    while (result_cursor != NULL) {
-+      if (shoots_result_is_provider_terminal(result_cursor)) {
-+        result_records[index] = result_cursor;
-+        index++;
-+      }
-+      result_cursor = result_cursor->next;
-+    }
-+    qsort(result_records, result_count, sizeof(*result_records),
-+          shoots_provider_result_compare);
-   }
--  if (first->provider_id_len < second->provider_id_len) {
--    return -1;
-+
-+  size_t total_len = 0;
-+  int header_len = snprintf(NULL, 0,
-+                            "provider_registry count=%zu digest=0x%016" PRIx64 "\n",
-+                            engine->provider_count, registry_digest);
-+  if (header_len < 0) {
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "snapshot format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-   }
--  if (first->provider_id_len > second->provider_id_len) {
--    return 1;
-+  shoots_error_code_t size_status =
-+      shoots_snapshot_add_size(&total_len, (size_t)header_len, out_error);
-+  if (size_status != SHOOTS_OK) {
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+    return size_status;
-   }
--  if (first->provider_id_len > 0) {
--    int provider_cmp = memcmp(first->provider_id, second->provider_id,
--                              first->provider_id_len);
--    if (provider_cmp != 0) {
--      return provider_cmp;
-+  for (size_t index = 0; index < engine->provider_count; index++) {
-+    const shoots_provider_descriptor_t *provider = &engine->providers[index];
-+    int line_len = snprintf(NULL, 0,
-+                            "provider[%zu] provider_id=%.*s categories=0x%08" PRIx32
-+                            " max_concurrency=%" PRIu32 " guarantees=0x%08" PRIx32 "\n",
-+                            index,
-+                            (int)provider->provider_id_len,
-+                            provider->provider_id,
-+                            provider->supported_tool_categories,
-+                            provider->max_concurrency,
-+                            provider->guarantees_mask);
-+    if (line_len < 0) {
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                       "snapshot format failed");
-+      return SHOOTS_ERR_INVALID_STATE;
-+    }
-+    size_status = shoots_snapshot_add_size(&total_len, (size_t)line_len, out_error);
-+    if (size_status != SHOOTS_OK) {
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+      return size_status;
-     }
-   }
--  if (first->tool_id_len < second->tool_id_len) {
--    return -1;
-+  int request_header_len = snprintf(NULL, 0, "provider_requests count=%zu\n",
-+                                    request_count);
-+  if (request_header_len < 0) {
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "snapshot format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-   }
--  if (first->tool_id_len > second->tool_id_len) {
--    return 1;
-+  size_status = shoots_snapshot_add_size(&total_len,
-+                                         (size_t)request_header_len,
-+                                         out_error);
-+  if (size_status != SHOOTS_OK) {
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+    return size_status;
-   }
--  if (first->tool_id_len > 0) {
--    int tool_cmp = memcmp(first->tool_id, second->tool_id, first->tool_id_len);
--    if (tool_cmp != 0) {
--      return tool_cmp;
-+  for (size_t index = 0; index < request_count; index++) {
-+    const shoots_provider_request_record_t *record = request_records[index];
-+    int prefix_len = snprintf(NULL, 0,
-+                              "request[%zu] session_id=%" PRIu64
-+                              " plan_id=%" PRIu64 " execution_slot=%" PRIu64
-+                              " request_id=0x%016" PRIx64
-+                              " provider_id=%.*s tool_id=%.*s tool_version=%" PRIu32
-+                              " capability_mask=0x%016" PRIx64
-+                              " input_hash=0x%016" PRIx64
-+                              " arg_size=%" PRIu32 " arg_hex=",
-+                              index,
-+                              record->session_id,
-+                              record->plan_id,
-+                              record->execution_slot,
-+                              record->request_id,
-+                              (int)record->provider_id_len,
-+                              record->provider_id,
-+                              (int)record->tool_id_len,
-+                              record->tool_id,
-+                              record->tool_version,
-+                              record->capability_mask,
-+                              record->input_hash,
-+                              record->arg_size);
-+    if (prefix_len < 0) {
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                       "snapshot format failed");
-+      return SHOOTS_ERR_INVALID_STATE;
-+    }
-+    size_t line_len = (size_t)prefix_len + (size_t)record->arg_size * 2u + 1u;
-+    size_status = shoots_snapshot_add_size(&total_len, line_len, out_error);
-+    if (size_status != SHOOTS_OK) {
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+      return size_status;
-     }
-   }
--  if (first->tool_version < second->tool_version) {
--    return -1;
-+  int result_header_len = snprintf(NULL, 0, "provider_results count=%zu\n",
-+                                   result_count);
-+  if (result_header_len < 0) {
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "snapshot format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-   }
--  if (first->tool_version > second->tool_version) {
--    return 1;
-+  size_status = shoots_snapshot_add_size(&total_len, (size_t)result_header_len, out_error);
-+  if (size_status != SHOOTS_OK) {
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+    return size_status;
-   }
--  if (first->capability_mask < second->capability_mask) {
--    return -1;
-+  for (size_t index = 0; index < result_count; index++) {
-+    const shoots_result_record_t *result = result_records[index];
-+    const char *command_id = result->command_id != NULL ? result->command_id : "";
-+    const char *payload = result->payload != NULL ? result->payload : "";
-+    int line_len = snprintf(NULL, 0,
-+                            "result[%zu] session_id=%" PRIu64
-+                            " execution_slot=%" PRIu64
-+                            " ledger_entry_id=%" PRIu64
-+                            " command_id=%s status=%d payload=%s\n",
-+                            index,
-+                            result->session_id,
-+                            result->execution_slot,
-+                            result->ledger_entry_id,
-+                            command_id,
-+                            result->status,
-+                            payload);
-+    if (line_len < 0) {
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                       "snapshot format failed");
-+      return SHOOTS_ERR_INVALID_STATE;
-+    }
-+    size_status = shoots_snapshot_add_size(&total_len, (size_t)line_len, out_error);
-+    if (size_status != SHOOTS_OK) {
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+      return size_status;
-+    }
-   }
--  if (first->capability_mask > second->capability_mask) {
--    return 1;
-+  if (total_len > SIZE_MAX - 1) {
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+    shoots_error_set(out_error, SHOOTS_ERR_OUT_OF_MEMORY, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "snapshot size overflow");
-+    return SHOOTS_ERR_OUT_OF_MEMORY;
-   }
--  if (first->input_hash < second->input_hash) {
--    return -1;
-+  char *buffer =
-+      (char *)shoots_engine_alloc_internal((shoots_engine_t *)engine,
-+                                           total_len + 1, out_error);
-+  if (buffer == NULL) {
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+    return SHOOTS_ERR_OUT_OF_MEMORY;
-   }
--  if (first->input_hash > second->input_hash) {
--    return 1;
-+  size_t offset = 0;
-+  int written = snprintf(buffer + offset, total_len + 1 - offset,
-+                         "provider_registry count=%zu digest=0x%016" PRIx64 "\n",
-+                         engine->provider_count, registry_digest);
-+  if (written < 0) {
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, buffer);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "snapshot format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-   }
--  if (first->arg_size < second->arg_size) {
--    return -1;
-+  offset += (size_t)written;
-+  for (size_t index = 0; index < engine->provider_count; index++) {
-+    const shoots_provider_descriptor_t *provider = &engine->providers[index];
-+    written = snprintf(buffer + offset, total_len + 1 - offset,
-+                       "provider[%zu] provider_id=%.*s categories=0x%08" PRIx32
-+                       " max_concurrency=%" PRIu32 " guarantees=0x%08" PRIx32 "\n",
-+                       index,
-+                       (int)provider->provider_id_len,
-+                       provider->provider_id,
-+                       provider->supported_tool_categories,
-+                       provider->max_concurrency,
-+                       provider->guarantees_mask);
-+    if (written < 0) {
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, buffer);
-+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                       "snapshot format failed");
-+      return SHOOTS_ERR_INVALID_STATE;
-+    }
-+    offset += (size_t)written;
-   }
--  if (first->arg_size > second->arg_size) {
--    return 1;
-+  written = snprintf(buffer + offset, total_len + 1 - offset,
-+                     "provider_requests count=%zu\n", request_count);
-+  if (written < 0) {
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, buffer);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "snapshot format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  offset += (size_t)written;
-+  for (size_t index = 0; index < request_count; index++) {
-+    const shoots_provider_request_record_t *record = request_records[index];
-+    written = snprintf(buffer + offset, total_len + 1 - offset,
-+                       "request[%zu] session_id=%" PRIu64
-+                       " plan_id=%" PRIu64 " execution_slot=%" PRIu64
-+                       " request_id=0x%016" PRIx64
-+                       " provider_id=%.*s tool_id=%.*s tool_version=%" PRIu32
-+                       " capability_mask=0x%016" PRIx64
-+                       " input_hash=0x%016" PRIx64
-+                       " arg_size=%" PRIu32 " arg_hex=",
-+                       index,
-+                       record->session_id,
-+                       record->plan_id,
-+                       record->execution_slot,
-+                       record->request_id,
-+                       (int)record->provider_id_len,
-+                       record->provider_id,
-+                       (int)record->tool_id_len,
-+                       record->tool_id,
-+                       record->tool_version,
-+                       record->capability_mask,
-+                       record->input_hash,
-+                       record->arg_size);
-+    if (written < 0) {
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, buffer);
-+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                       "snapshot format failed");
-+      return SHOOTS_ERR_INVALID_STATE;
-+    }
-+    offset += (size_t)written;
-+    if (record->arg_size > 0) {
-+      shoots_snapshot_write_hex(buffer, offset, record->arg_blob, record->arg_size);
-+      offset += (size_t)record->arg_size * 2u;
-+    }
-+    buffer[offset] = '\n';
-+    offset += 1;
-+  }
-+  written = snprintf(buffer + offset, total_len + 1 - offset,
-+                     "provider_results count=%zu\n", result_count);
-+  if (written < 0) {
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, buffer);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "snapshot format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  offset += (size_t)written;
-+  for (size_t index = 0; index < result_count; index++) {
-+    const shoots_result_record_t *result = result_records[index];
-+    const char *command_id = result->command_id != NULL ? result->command_id : "";
-+    const char *payload = result->payload != NULL ? result->payload : "";
-+    written = snprintf(buffer + offset, total_len + 1 - offset,
-+                       "result[%zu] session_id=%" PRIu64
-+                       " execution_slot=%" PRIu64
-+                       " ledger_entry_id=%" PRIu64
-+                       " command_id=%s status=%d payload=%s\n",
-+                       index,
-+                       result->session_id,
-+                       result->execution_slot,
-+                       result->ledger_entry_id,
-+                       command_id,
-+                       result->status,
-+                       payload);
-+    if (written < 0) {
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+      shoots_engine_alloc_free_internal((shoots_engine_t *)engine, buffer);
-+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                       "snapshot format failed");
-+      return SHOOTS_ERR_INVALID_STATE;
-+    }
-+    offset += (size_t)written;
-+  }
-+  buffer[offset] = '\0';
-+  shoots_engine_alloc_free_internal((shoots_engine_t *)engine, request_records);
-+  shoots_engine_alloc_free_internal((shoots_engine_t *)engine, result_records);
-+  *out_snapshot = buffer;
-+  *out_length = total_len;
-+  return SHOOTS_OK;
-+}
-+
-+static int shoots_provider_request_record_compare(const void *left, const void *right) {
-+  const shoots_provider_request_record_t *first =
-+      *(const shoots_provider_request_record_t *const *)left;
-+  const shoots_provider_request_record_t *second =
-+      *(const shoots_provider_request_record_t *const *)right;
-+  if (first->request_id < second->request_id) {
-+    return -1;
-+  }
-+  if (first->request_id > second->request_id) {
-+    return 1;
-+  }
-+  if (first->session_id < second->session_id) {
-+    return -1;
-+  }
-+  if (first->session_id > second->session_id) {
-+    return 1;
-+  }
-+  if (first->plan_id < second->plan_id) {
-+    return -1;
-+  }
-+  if (first->plan_id > second->plan_id) {
-+    return 1;
-+  }
-+  if (first->execution_slot < second->execution_slot) {
-+    return -1;
-+  }
-+  if (first->execution_slot > second->execution_slot) {
-+    return 1;
-+  }
-+  if (first->provider_id_len < second->provider_id_len) {
-+    return -1;
-+  }
-+  if (first->provider_id_len > second->provider_id_len) {
-+    return 1;
-+  }
-+  if (first->provider_id_len > 0) {
-+    int provider_cmp = memcmp(first->provider_id, second->provider_id,
-+                              first->provider_id_len);
-+    if (provider_cmp != 0) {
-+      return provider_cmp;
-+    }
-+  }
-+  if (first->tool_id_len < second->tool_id_len) {
-+    return -1;
-+  }
-+  if (first->tool_id_len > second->tool_id_len) {
-+    return 1;
-+  }
-+  if (first->tool_id_len > 0) {
-+    int tool_cmp = memcmp(first->tool_id, second->tool_id, first->tool_id_len);
-+    if (tool_cmp != 0) {
-+      return tool_cmp;
-+    }
-+  }
-+  if (first->tool_version < second->tool_version) {
-+    return -1;
-+  }
-+  if (first->tool_version > second->tool_version) {
-+    return 1;
-+  }
-+  if (first->capability_mask < second->capability_mask) {
-+    return -1;
-+  }
-+  if (first->capability_mask > second->capability_mask) {
-+    return 1;
-+  }
-+  if (first->input_hash < second->input_hash) {
-+    return -1;
-+  }
-+  if (first->input_hash > second->input_hash) {
-+    return 1;
-+  }
-+  if (first->arg_size < second->arg_size) {
-+    return -1;
-+  }
-+  if (first->arg_size > second->arg_size) {
-+    return 1;
-   }
-   if (first->arg_size > 0) {
-     int arg_cmp = memcmp(first->arg_blob, second->arg_blob, first->arg_size);
-@@ -2725,358 +3085,33 @@ shoots_error_code_t shoots_provider_snapshot_export_internal(
-   char **out_snapshot,
-   size_t *out_length,
-   shoots_error_info_t *out_error) {
--  shoots_error_clear(out_error);
--  if (out_snapshot == NULL || out_length == NULL) {
--    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
--                     "output is null");
--    return SHOOTS_ERR_INVALID_ARGUMENT;
--  }
--  *out_snapshot = NULL;
--  *out_length = 0;
--  shoots_error_code_t engine_status = shoots_validate_engine(engine, out_error);
--  if (engine_status != SHOOTS_OK) {
--    return engine_status;
-+  shoots_error_code_t status =
-+      shoots_provider_snapshot_build(engine, out_snapshot, out_length, out_error);
-+  if (status != SHOOTS_OK) {
-+    return status;
-   }
-   engine->provider_snapshot_exported = 1;
-   shoots_provider_maybe_seal(engine);
--  uint64_t registry_digest = shoots_provider_registry_digest(engine);
--
--  size_t request_count = 0;
--  shoots_provider_request_record_t *request_cursor = engine->provider_requests_head;
--  while (request_cursor != NULL) {
--    request_count++;
--    request_cursor = request_cursor->next;
--  }
--  shoots_provider_request_record_t **request_records = NULL;
--  if (request_count > 0) {
--    request_records = (shoots_provider_request_record_t **)shoots_engine_alloc_internal(
--        engine, request_count * sizeof(*request_records), out_error);
--    if (request_records == NULL) {
--      return SHOOTS_ERR_OUT_OF_MEMORY;
--    }
--    size_t index = 0;
--    request_cursor = engine->provider_requests_head;
--    while (request_cursor != NULL) {
--      request_records[index] = request_cursor;
--      index++;
--      request_cursor = request_cursor->next;
--    }
--    qsort(request_records, request_count, sizeof(*request_records),
--          shoots_provider_request_record_compare);
--  }
-+  return SHOOTS_OK;
-+}
- 
--  size_t result_count = 0;
--  shoots_result_record_t *result_cursor = engine->results_head;
--  while (result_cursor != NULL) {
--    if (shoots_result_is_provider_terminal(result_cursor)) {
--      result_count++;
--    }
--    result_cursor = result_cursor->next;
--  }
--  shoots_result_record_t **result_records = NULL;
--  if (result_count > 0) {
--    result_records = (shoots_result_record_t **)shoots_engine_alloc_internal(
--        engine, result_count * sizeof(*result_records), out_error);
--    if (result_records == NULL) {
--      shoots_engine_alloc_free_internal(engine, request_records);
--      return SHOOTS_ERR_OUT_OF_MEMORY;
--    }
--    size_t index = 0;
--    result_cursor = engine->results_head;
--    while (result_cursor != NULL) {
--      if (shoots_result_is_provider_terminal(result_cursor)) {
--        result_records[index] = result_cursor;
--        index++;
--      }
--      result_cursor = result_cursor->next;
--    }
--    qsort(result_records, result_count, sizeof(*result_records),
--          shoots_provider_result_compare);
--  }
-+shoots_error_code_t shoots_engine_export_provider_snapshot(
-+  const shoots_engine_t *engine,
-+  char **out_snapshot,
-+  size_t *out_length,
-+  shoots_error_info_t *out_error) {
-+  return shoots_provider_snapshot_build(engine, out_snapshot, out_length, out_error);
-+}
- 
--  size_t total_len = 0;
--  int header_len = snprintf(NULL, 0,
--                            "provider_registry count=%zu digest=0x%016" PRIx64 "\n",
--                            engine->provider_count, registry_digest);
--  if (header_len < 0) {
--    shoots_engine_alloc_free_internal(engine, request_records);
--    shoots_engine_alloc_free_internal(engine, result_records);
--    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--                     "snapshot format failed");
--    return SHOOTS_ERR_INVALID_STATE;
--  }
--  shoots_error_code_t size_status =
--      shoots_snapshot_add_size(&total_len, (size_t)header_len, out_error);
--  if (size_status != SHOOTS_OK) {
--    shoots_engine_alloc_free_internal(engine, request_records);
--    shoots_engine_alloc_free_internal(engine, result_records);
--    return size_status;
--  }
--  for (size_t index = 0; index < engine->provider_count; index++) {
--    const shoots_provider_descriptor_t *provider = &engine->providers[index];
--    int line_len = snprintf(NULL, 0,
--                            "provider[%zu] provider_id=%.*s categories=0x%08" PRIx32
--                            " max_concurrency=%" PRIu32 " guarantees=0x%08" PRIx32 "\n",
--                            index,
--                            (int)provider->provider_id_len,
--                            provider->provider_id,
--                            provider->supported_tool_categories,
--                            provider->max_concurrency,
--                            provider->guarantees_mask);
--    if (line_len < 0) {
--      shoots_engine_alloc_free_internal(engine, request_records);
--      shoots_engine_alloc_free_internal(engine, result_records);
--      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--                       "snapshot format failed");
--      return SHOOTS_ERR_INVALID_STATE;
--    }
--    size_status = shoots_snapshot_add_size(&total_len, (size_t)line_len, out_error);
--    if (size_status != SHOOTS_OK) {
--      shoots_engine_alloc_free_internal(engine, request_records);
--      shoots_engine_alloc_free_internal(engine, result_records);
--      return size_status;
--    }
--  }
--  int request_header_len = snprintf(NULL, 0, "provider_requests count=%zu\n",
--                                    request_count);
--  if (request_header_len < 0) {
--    shoots_engine_alloc_free_internal(engine, request_records);
--    shoots_engine_alloc_free_internal(engine, result_records);
--    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--                     "snapshot format failed");
--    return SHOOTS_ERR_INVALID_STATE;
--  }
--  size_status = shoots_snapshot_add_size(&total_len,
--                                         (size_t)request_header_len,
--                                         out_error);
--  if (size_status != SHOOTS_OK) {
--    shoots_engine_alloc_free_internal(engine, request_records);
--    shoots_engine_alloc_free_internal(engine, result_records);
--    return size_status;
--  }
--  for (size_t index = 0; index < request_count; index++) {
--    const shoots_provider_request_record_t *record = request_records[index];
--    int prefix_len = snprintf(NULL, 0,
--                              "request[%zu] session_id=%" PRIu64
--                              " plan_id=%" PRIu64 " execution_slot=%" PRIu64
--                              " request_id=0x%016" PRIx64
--                              " provider_id=%.*s tool_id=%.*s tool_version=%" PRIu32
--                              " capability_mask=0x%016" PRIx64
--                              " input_hash=0x%016" PRIx64
--                              " arg_size=%" PRIu32 " arg_hex=",
--                              index,
--                              record->session_id,
--                              record->plan_id,
--                              record->execution_slot,
--                              record->request_id,
--                              (int)record->provider_id_len,
--                              record->provider_id,
--                              (int)record->tool_id_len,
--                              record->tool_id,
--                              record->tool_version,
--                              record->capability_mask,
--                              record->input_hash,
--                              record->arg_size);
--    if (prefix_len < 0) {
--      shoots_engine_alloc_free_internal(engine, request_records);
--      shoots_engine_alloc_free_internal(engine, result_records);
--      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--                       "snapshot format failed");
--      return SHOOTS_ERR_INVALID_STATE;
--    }
--    size_t line_len = (size_t)prefix_len + (size_t)record->arg_size * 2u + 1u;
--    size_status = shoots_snapshot_add_size(&total_len, line_len, out_error);
--    if (size_status != SHOOTS_OK) {
--      shoots_engine_alloc_free_internal(engine, request_records);
--      shoots_engine_alloc_free_internal(engine, result_records);
--      return size_status;
--    }
--  }
--  int result_header_len = snprintf(NULL, 0, "provider_results count=%zu\n",
--                                   result_count);
--  if (result_header_len < 0) {
--    shoots_engine_alloc_free_internal(engine, request_records);
--    shoots_engine_alloc_free_internal(engine, result_records);
--    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--                     "snapshot format failed");
--    return SHOOTS_ERR_INVALID_STATE;
--  }
--  size_status = shoots_snapshot_add_size(&total_len, (size_t)result_header_len, out_error);
--  if (size_status != SHOOTS_OK) {
--    shoots_engine_alloc_free_internal(engine, request_records);
--    shoots_engine_alloc_free_internal(engine, result_records);
--    return size_status;
--  }
--  for (size_t index = 0; index < result_count; index++) {
--    const shoots_result_record_t *result = result_records[index];
--    const char *command_id = result->command_id != NULL ? result->command_id : "";
--    const char *payload = result->payload != NULL ? result->payload : "";
--    int line_len = snprintf(NULL, 0,
--                            "result[%zu] session_id=%" PRIu64
--                            " execution_slot=%" PRIu64
--                            " ledger_entry_id=%" PRIu64
--                            " command_id=%s status=%d payload=%s\n",
--                            index,
--                            result->session_id,
--                            result->execution_slot,
--                            result->ledger_entry_id,
--                            command_id,
--                            result->status,
--                            payload);
--    if (line_len < 0) {
--      shoots_engine_alloc_free_internal(engine, request_records);
--      shoots_engine_alloc_free_internal(engine, result_records);
--      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--                       "snapshot format failed");
--      return SHOOTS_ERR_INVALID_STATE;
--    }
--    size_status = shoots_snapshot_add_size(&total_len, (size_t)line_len, out_error);
--    if (size_status != SHOOTS_OK) {
--      shoots_engine_alloc_free_internal(engine, request_records);
--      shoots_engine_alloc_free_internal(engine, result_records);
--      return size_status;
--    }
--  }
--  if (total_len > SIZE_MAX - 1) {
--    shoots_engine_alloc_free_internal(engine, request_records);
--    shoots_engine_alloc_free_internal(engine, result_records);
--    shoots_error_set(out_error, SHOOTS_ERR_OUT_OF_MEMORY, SHOOTS_SEVERITY_RECOVERABLE,
--                     "snapshot size overflow");
--    return SHOOTS_ERR_OUT_OF_MEMORY;
--  }
--  char *buffer = (char *)shoots_engine_alloc_internal(engine, total_len + 1, out_error);
--  if (buffer == NULL) {
--    shoots_engine_alloc_free_internal(engine, request_records);
--    shoots_engine_alloc_free_internal(engine, result_records);
--    return SHOOTS_ERR_OUT_OF_MEMORY;
--  }
--  size_t offset = 0;
--  int written = snprintf(buffer + offset, total_len + 1 - offset,
--                         "provider_registry count=%zu digest=0x%016" PRIx64 "\n",
--                         engine->provider_count, registry_digest);
--  if (written < 0) {
--    shoots_engine_alloc_free_internal(engine, request_records);
--    shoots_engine_alloc_free_internal(engine, result_records);
--    shoots_engine_alloc_free_internal(engine, buffer);
--    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--                     "snapshot format failed");
--    return SHOOTS_ERR_INVALID_STATE;
--  }
--  offset += (size_t)written;
--  for (size_t index = 0; index < engine->provider_count; index++) {
--    const shoots_provider_descriptor_t *provider = &engine->providers[index];
--    written = snprintf(buffer + offset, total_len + 1 - offset,
--                       "provider[%zu] provider_id=%.*s categories=0x%08" PRIx32
--                       " max_concurrency=%" PRIu32 " guarantees=0x%08" PRIx32 "\n",
--                       index,
--                       (int)provider->provider_id_len,
--                       provider->provider_id,
--                       provider->supported_tool_categories,
--                       provider->max_concurrency,
--                       provider->guarantees_mask);
--    if (written < 0) {
--      shoots_engine_alloc_free_internal(engine, request_records);
--      shoots_engine_alloc_free_internal(engine, result_records);
--      shoots_engine_alloc_free_internal(engine, buffer);
--      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--                       "snapshot format failed");
--      return SHOOTS_ERR_INVALID_STATE;
--    }
--    offset += (size_t)written;
--  }
--  written = snprintf(buffer + offset, total_len + 1 - offset,
--                     "provider_requests count=%zu\n", request_count);
--  if (written < 0) {
--    shoots_engine_alloc_free_internal(engine, request_records);
--    shoots_engine_alloc_free_internal(engine, result_records);
--    shoots_engine_alloc_free_internal(engine, buffer);
--    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--                     "snapshot format failed");
--    return SHOOTS_ERR_INVALID_STATE;
--  }
--  offset += (size_t)written;
--  for (size_t index = 0; index < request_count; index++) {
--    const shoots_provider_request_record_t *record = request_records[index];
--    written = snprintf(buffer + offset, total_len + 1 - offset,
--                       "request[%zu] session_id=%" PRIu64
--                       " plan_id=%" PRIu64 " execution_slot=%" PRIu64
--                       " request_id=0x%016" PRIx64
--                       " provider_id=%.*s tool_id=%.*s tool_version=%" PRIu32
--                       " capability_mask=0x%016" PRIx64
--                       " input_hash=0x%016" PRIx64
--                       " arg_size=%" PRIu32 " arg_hex=",
--                       index,
--                       record->session_id,
--                       record->plan_id,
--                       record->execution_slot,
--                       record->request_id,
--                       (int)record->provider_id_len,
--                       record->provider_id,
--                       (int)record->tool_id_len,
--                       record->tool_id,
--                       record->tool_version,
--                       record->capability_mask,
--                       record->input_hash,
--                       record->arg_size);
--    if (written < 0) {
--      shoots_engine_alloc_free_internal(engine, request_records);
--      shoots_engine_alloc_free_internal(engine, result_records);
--      shoots_engine_alloc_free_internal(engine, buffer);
--      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--                       "snapshot format failed");
--      return SHOOTS_ERR_INVALID_STATE;
--    }
--    offset += (size_t)written;
--    if (record->arg_size > 0) {
--      shoots_snapshot_write_hex(buffer, offset, record->arg_blob, record->arg_size);
--      offset += (size_t)record->arg_size * 2u;
--    }
--    buffer[offset] = '\n';
--    offset += 1;
--  }
--  written = snprintf(buffer + offset, total_len + 1 - offset,
--                     "provider_results count=%zu\n", result_count);
--  if (written < 0) {
--    shoots_engine_alloc_free_internal(engine, request_records);
--    shoots_engine_alloc_free_internal(engine, result_records);
--    shoots_engine_alloc_free_internal(engine, buffer);
--    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--                     "snapshot format failed");
--    return SHOOTS_ERR_INVALID_STATE;
--  }
--  offset += (size_t)written;
--  for (size_t index = 0; index < result_count; index++) {
--    const shoots_result_record_t *result = result_records[index];
--    const char *command_id = result->command_id != NULL ? result->command_id : "";
--    const char *payload = result->payload != NULL ? result->payload : "";
--    written = snprintf(buffer + offset, total_len + 1 - offset,
--                       "result[%zu] session_id=%" PRIu64
--                       " execution_slot=%" PRIu64
--                       " ledger_entry_id=%" PRIu64
--                       " command_id=%s status=%d payload=%s\n",
--                       index,
--                       result->session_id,
--                       result->execution_slot,
--                       result->ledger_entry_id,
--                       command_id,
--                       result->status,
--                       payload);
--    if (written < 0) {
--      shoots_engine_alloc_free_internal(engine, request_records);
--      shoots_engine_alloc_free_internal(engine, result_records);
--      shoots_engine_alloc_free_internal(engine, buffer);
--      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--                       "snapshot format failed");
--      return SHOOTS_ERR_INVALID_STATE;
--    }
--    offset += (size_t)written;
--  }
--  buffer[offset] = '\0';
--  shoots_engine_alloc_free_internal(engine, request_records);
--  shoots_engine_alloc_free_internal(engine, result_records);
--  *out_snapshot = buffer;
--  *out_length = total_len;
--  return SHOOTS_OK;
-+shoots_error_code_t shoots_engine_export_pending_provider_requests(
-+  const shoots_engine_t *engine,
-+  shoots_provider_request_t **out_requests,
-+  size_t *out_count,
-+  shoots_error_info_t *out_error) {
-+  return shoots_provider_requests_export_internal((shoots_engine_t *)engine,
-+                                                  out_requests,
-+                                                  out_count,
-+                                                  out_error);
- }
- 
- uint8_t shoots_engine_provider_ready(const shoots_engine_t *engine) {
-diff --git a/tools/engine/src/execution_spine.h b/tools/engine/src/execution_spine.h
-index 9c2c805..3b4ee7e 100644
---- a/tools/engine/src/execution_spine.h
-+++ b/tools/engine/src/execution_spine.h
-@@ -3,6 +3,23 @@
- 
- #include "engine_internal.h"
- 
-+/* BUILDER-ONLY FROZEN PROVIDER QUERIES (NO MUTATION) */
-+shoots_error_code_t shoots_engine_export_provider_snapshot(
-+  const shoots_engine_t *engine,
-+  char **out_snapshot,
-+  size_t *out_length,
-+  shoots_error_info_t *out_error);
-+
-+shoots_error_code_t shoots_engine_export_pending_provider_requests(
-+  const shoots_engine_t *engine,
-+  shoots_provider_request_t **out_requests,
-+  size_t *out_count,
-+  shoots_error_info_t *out_error);
-+
-+uint8_t shoots_engine_provider_ready(const shoots_engine_t *engine);
-+
-+/* END BUILDER-ONLY FROZEN PROVIDER QUERIES */
-+
- shoots_error_code_t spine_record_intent(
-   shoots_engine_t *engine,
-   const char *intent_id,
-diff --git a/tools/engine/src/provider_runtime.h b/tools/engine/src/provider_runtime.h
-index c31b5c8..6bc80df 100644
---- a/tools/engine/src/provider_runtime.h
-+++ b/tools/engine/src/provider_runtime.h
-@@ -71,6 +71,23 @@ typedef struct shoots_provider_descriptor {
-   uint32_t guarantees_mask;
- } shoots_provider_descriptor_t;
- 
-+/* BUILDER-ONLY FROZEN PROVIDER QUERIES (NO MUTATION) */
-+shoots_error_code_t shoots_engine_export_provider_snapshot(
-+  const shoots_engine_t *engine,
-+  char **out_snapshot,
-+  size_t *out_length,
-+  shoots_error_info_t *out_error);
-+
-+shoots_error_code_t shoots_engine_export_pending_provider_requests(
-+  const shoots_engine_t *engine,
-+  shoots_provider_request_t **out_requests,
-+  size_t *out_count,
-+  shoots_error_info_t *out_error);
-+
-+uint8_t shoots_engine_provider_ready(const shoots_engine_t *engine);
-+
-+/* END BUILDER-ONLY FROZEN PROVIDER QUERIES */
-+
- shoots_error_code_t shoots_provider_descriptor_validate(
-   const shoots_provider_descriptor_t *descriptor,
-   shoots_error_info_t *out_error);
diff --git a/.ai/patches/patch-2026-01-30-03-47-09.diff b/.ai/patches/patch-2026-01-30-03-47-09.diff
deleted file mode 100644
index b5a32e7..0000000
--- a/.ai/patches/patch-2026-01-30-03-47-09.diff
+++ /dev/null
@@ -1,28 +0,0 @@
-diff --git a/tools/engine/src/engine_internal.h b/tools/engine/src/engine_internal.h
-index f0cb16e..5d245d1 100644
---- a/tools/engine/src/engine_internal.h
-+++ b/tools/engine/src/engine_internal.h
-@@ -465,8 +465,23 @@ shoots_error_code_t shoots_provider_snapshot_export_internal(
-   size_t *out_length,
-   shoots_error_info_t *out_error);
- 
-+/* BUILDER-ONLY FROZEN PROVIDER QUERIES (NO MUTATION) */
-+shoots_error_code_t shoots_engine_export_provider_snapshot(
-+  const shoots_engine_t *engine,
-+  char **out_snapshot,
-+  size_t *out_length,
-+  shoots_error_info_t *out_error);
-+
-+shoots_error_code_t shoots_engine_export_pending_provider_requests(
-+  const shoots_engine_t *engine,
-+  shoots_provider_request_t **out_requests,
-+  size_t *out_count,
-+  shoots_error_info_t *out_error);
-+
- uint8_t shoots_engine_provider_ready(const shoots_engine_t *engine);
- 
-+/* END BUILDER-ONLY FROZEN PROVIDER QUERIES */
-+
- shoots_error_code_t shoots_command_append_internal(
-   shoots_engine_t *engine,
-   shoots_session_t *session,
diff --git a/.ai/patches/patch-2026-01-30-03-50-12.diff b/.ai/patches/patch-2026-01-30-03-50-12.diff
deleted file mode 100644
index 19ecfaa..0000000
--- a/.ai/patches/patch-2026-01-30-03-50-12.diff
+++ /dev/null
@@ -1,132 +0,0 @@
-diff --git a/tools/engine/src/engine.c b/tools/engine/src/engine.c
-index b22ae29..318bc8e 100644
---- a/tools/engine/src/engine.c
-+++ b/tools/engine/src/engine.c
-@@ -195,6 +195,10 @@ static void shoots_assert_invariants(const shoots_engine_t *engine) {
-   assert(engine->tools_locked <= 1);
-   assert(engine->provider_count <= SHOOTS_ENGINE_MAX_PROVIDERS);
-   assert(engine->providers_locked <= 1);
-+  if (engine->provider_system_sealed) {
-+    assert(engine->providers_locked);
-+    assert(engine->provider_snapshot_exported);
-+  }
-   for (size_t index = 0; index < engine->provider_count; index++) {
-     const shoots_provider_descriptor_t *provider = &engine->providers[index];
-     assert(provider->provider_id_len > 0);
-diff --git a/tools/engine/src/provider_runtime.c b/tools/engine/src/provider_runtime.c
-index 568fe38..75b9c1e 100644
---- a/tools/engine/src/provider_runtime.c
-+++ b/tools/engine/src/provider_runtime.c
-@@ -734,6 +734,12 @@ shoots_error_code_t shoots_provider_registry_lock_internal(
-     return SHOOTS_ERR_INVALID_STATE;
-   }
-   engine->providers_locked = 1;
-+#ifndef NDEBUG
-+  assert(engine->providers_locked);
-+  if (engine->provider_system_sealed) {
-+    assert(engine->provider_snapshot_exported);
-+  }
-+#endif
-   if (engine->provider_snapshot_exported) {
-     engine->provider_system_sealed = 1;
-   }
-diff --git a/tools/engine/src/selfcheck.c b/tools/engine/src/selfcheck.c
-index 39691e2..87e9007 100644
---- a/tools/engine/src/selfcheck.c
-+++ b/tools/engine/src/selfcheck.c
-@@ -1,5 +1,6 @@
- #include "engine_internal.h"
- 
-+#include <stdlib.h>
- #include <string.h>
- #ifndef NDEBUG
- #include <assert.h>
-@@ -176,6 +177,15 @@ void selfcheck_run(shoots_engine_t *engine) {
-         if (result_match->session_id == provider_request->session_id &&
-             result_match->execution_slot == provider_request->execution_slot) {
-           result_found = 1;
-+          char expected_command_id[64];
-+          int expected_len = snprintf(expected_command_id, sizeof(expected_command_id),
-+                                      "provider_request=0x%016" PRIx64,
-+                                      provider_request->request_id);
-+          if (expected_len > 0 &&
-+              (size_t)expected_len < sizeof(expected_command_id) &&
-+              result_match->command_id != NULL) {
-+            assert(strcmp(result_match->command_id, expected_command_id) == 0);
-+          }
-           break;
-         }
-         result_match = result_match->next;
-@@ -190,9 +200,47 @@ void selfcheck_run(shoots_engine_t *engine) {
-       if (session_match->has_terminal_execution) {
-         assert(provider_request->execution_slot <= session_match->terminal_execution_slot);
-       }
-+    } else if (engine->provider_system_sealed) {
-+      assert(0 && "pending request after provider seal");
-+    }
-+    shoots_session_t *terminal_match = engine->sessions_head;
-+    while (terminal_match != NULL &&
-+           terminal_match->session_id != provider_request->session_id) {
-+      terminal_match = terminal_match->next;
-+    }
-+    if (terminal_match != NULL && terminal_match->has_terminal_execution &&
-+        provider_request->execution_slot <= terminal_match->terminal_execution_slot) {
-+      assert(provider_request->received);
-     }
-     provider_request = provider_request->next;
-   }
-+  shoots_result_record_t *provider_result = engine->results_head;
-+  while (provider_result != NULL) {
-+    if (provider_result->command_id != NULL &&
-+        strncmp(provider_result->command_id, "provider_request=",
-+                strlen("provider_request=")) == 0) {
-+      const char *request_id_str = strstr(provider_result->command_id, "0x");
-+      assert(request_id_str != NULL);
-+      if (request_id_str != NULL) {
-+        uint64_t request_id = strtoull(request_id_str, NULL, 16);
-+        shoots_provider_request_record_t *request_match =
-+            engine->provider_requests_head;
-+        int request_found = 0;
-+        while (request_match != NULL) {
-+          if (request_match->request_id == request_id) {
-+            request_found = 1;
-+            assert(request_match->received);
-+            assert(request_match->session_id == provider_result->session_id);
-+            assert(request_match->execution_slot == provider_result->execution_slot);
-+            break;
-+          }
-+          request_match = request_match->next;
-+        }
-+        assert(request_found);
-+      }
-+    }
-+    provider_result = provider_result->next;
-+  }
-   int terminal_seen = 0;
-   shoots_ledger_entry_t *ledger_guard = engine->ledger_head;
-   while (ledger_guard != NULL) {
-@@ -278,6 +326,24 @@ void selfcheck_run(shoots_engine_t *engine) {
-     }
-     result = result->next;
-   }
-+  shoots_result_record_t *terminal_result = engine->results_head;
-+  while (terminal_result != NULL) {
-+    if (terminal_result->command_id != NULL &&
-+        strncmp(terminal_result->command_id, "provider_request=",
-+                strlen("provider_request=")) == 0) {
-+      shoots_result_record_t *terminal_check = terminal_result->next;
-+      while (terminal_check != NULL) {
-+        if (terminal_check->command_id != NULL &&
-+            strncmp(terminal_check->command_id, "provider_request=",
-+                    strlen("provider_request=")) == 0 &&
-+            terminal_check->session_id == terminal_result->session_id) {
-+          assert(terminal_check->execution_slot != terminal_result->execution_slot);
-+        }
-+        terminal_check = terminal_check->next;
-+      }
-+    }
-+    terminal_result = terminal_result->next;
-+  }
-   shoots_session_t *terminal_session = engine->sessions_head;
-   while (terminal_session != NULL) {
-     if (terminal_session->has_terminal_execution) {
diff --git a/.ai/patches/patch-2026-01-30-03-58-28.diff b/.ai/patches/patch-2026-01-30-03-58-28.diff
deleted file mode 100644
index d1635ed..0000000
--- a/.ai/patches/patch-2026-01-30-03-58-28.diff
+++ /dev/null
@@ -1,242 +0,0 @@
-diff --git a/tools/engine/src/engine.c b/tools/engine/src/engine.c
-index 318bc8e..5d9f38a 100644
---- a/tools/engine/src/engine.c
-+++ b/tools/engine/src/engine.c
-@@ -3099,33 +3099,114 @@ shoots_error_code_t shoots_provider_snapshot_export_internal(
-   return SHOOTS_OK;
- }
- 
--shoots_error_code_t shoots_engine_export_provider_snapshot(
-+shoots_error_code_t shoots_engine_export_provider_snapshot_const(
-   const shoots_engine_t *engine,
--  char **out_snapshot,
--  size_t *out_length,
-+  shoots_provider_snapshot_t **out_snapshot,
-   shoots_error_info_t *out_error) {
--  return shoots_provider_snapshot_build(engine, out_snapshot, out_length, out_error);
-+  if (out_snapshot == NULL) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "output is null");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  *out_snapshot = NULL;
-+  char *payload = NULL;
-+  size_t payload_len = 0;
-+  shoots_error_code_t status =
-+      shoots_provider_snapshot_build(engine, &payload, &payload_len, out_error);
-+  if (status != SHOOTS_OK) {
-+    return status;
-+  }
-+  shoots_provider_snapshot_t *snapshot =
-+      (shoots_provider_snapshot_t *)shoots_engine_alloc_internal(
-+          (shoots_engine_t *)engine, sizeof(*snapshot), out_error);
-+  if (snapshot == NULL) {
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, payload);
-+    return SHOOTS_ERR_OUT_OF_MEMORY;
-+  }
-+  snapshot->payload = payload;
-+  snapshot->payload_len = payload_len;
-+  *out_snapshot = snapshot;
-+  return SHOOTS_OK;
- }
- 
--shoots_error_code_t shoots_engine_export_pending_provider_requests(
-+shoots_error_code_t shoots_engine_export_pending_provider_requests_const(
-   const shoots_engine_t *engine,
--  shoots_provider_request_t **out_requests,
-+  shoots_provider_request_record_t **out_list,
-   size_t *out_count,
-   shoots_error_info_t *out_error) {
--  return shoots_provider_requests_export_internal((shoots_engine_t *)engine,
--                                                  out_requests,
--                                                  out_count,
--                                                  out_error);
-+  shoots_error_clear(out_error);
-+  if (out_list == NULL || out_count == NULL) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "output is null");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  *out_list = NULL;
-+  *out_count = 0;
-+  shoots_error_code_t engine_status =
-+      shoots_validate_engine((shoots_engine_t *)engine, out_error);
-+  if (engine_status != SHOOTS_OK) {
-+    return engine_status;
-+  }
-+  size_t pending_count = 0;
-+  shoots_provider_request_record_t *cursor = engine->provider_requests_head;
-+  while (cursor != NULL) {
-+    if (!cursor->received) {
-+      pending_count++;
-+    }
-+    cursor = cursor->next;
-+  }
-+  if (pending_count == 0) {
-+    return SHOOTS_OK;
-+  }
-+  if (pending_count > SIZE_MAX / sizeof(shoots_provider_request_record_t)) {
-+    shoots_error_set(out_error, SHOOTS_ERR_OUT_OF_MEMORY, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "request export size overflow");
-+    return SHOOTS_ERR_OUT_OF_MEMORY;
-+  }
-+  shoots_provider_request_record_t **records =
-+      (shoots_provider_request_record_t **)shoots_engine_alloc_internal(
-+          (shoots_engine_t *)engine, pending_count * sizeof(*records), out_error);
-+  if (records == NULL) {
-+    return SHOOTS_ERR_OUT_OF_MEMORY;
-+  }
-+  size_t index = 0;
-+  cursor = engine->provider_requests_head;
-+  while (cursor != NULL) {
-+    if (!cursor->received) {
-+      records[index] = cursor;
-+      index++;
-+    }
-+    cursor = cursor->next;
-+  }
-+  qsort(records, pending_count, sizeof(*records), shoots_provider_request_record_compare);
-+  shoots_provider_request_record_t *copy =
-+      (shoots_provider_request_record_t *)shoots_engine_alloc_internal(
-+          (shoots_engine_t *)engine, pending_count * sizeof(*copy), out_error);
-+  if (copy == NULL) {
-+    shoots_engine_alloc_free_internal((shoots_engine_t *)engine, records);
-+    return SHOOTS_ERR_OUT_OF_MEMORY;
-+  }
-+  for (size_t i = 0; i < pending_count; i++) {
-+    copy[i] = *records[i];
-+    copy[i].next = NULL;
-+  }
-+  shoots_engine_alloc_free_internal((shoots_engine_t *)engine, records);
-+  *out_list = copy;
-+  *out_count = pending_count;
-+  return SHOOTS_OK;
- }
- 
--uint8_t shoots_engine_provider_ready(const shoots_engine_t *engine) {
-+int shoots_engine_provider_ready(const shoots_engine_t *engine) {
-   if (engine == NULL) {
-     return 0;
-   }
-   if (engine->state != SHOOTS_ENGINE_STATE_INITIALIZED) {
-     return 0;
-   }
--  if (!engine->providers_locked || !engine->provider_system_sealed) {
-+  if (!engine->providers_locked) {
-+    return 0;
-+  }
-+  if (!(engine->provider_snapshot_exported || engine->provider_system_sealed)) {
-     return 0;
-   }
-   if (engine->provider_count == 0) {
-diff --git a/tools/engine/src/engine_internal.h b/tools/engine/src/engine_internal.h
-index 5d245d1..89e3a5c 100644
---- a/tools/engine/src/engine_internal.h
-+++ b/tools/engine/src/engine_internal.h
-@@ -465,20 +465,21 @@ shoots_error_code_t shoots_provider_snapshot_export_internal(
-   size_t *out_length,
-   shoots_error_info_t *out_error);
- 
--/* BUILDER-ONLY FROZEN PROVIDER QUERIES (NO MUTATION) */
--shoots_error_code_t shoots_engine_export_provider_snapshot(
-+/* BUILDER-ONLY */
-+/* READ-ONLY */
-+/* FROZEN API  DO NOT EXTEND WITHOUT PHASE BUMP */
-+shoots_error_code_t shoots_engine_export_provider_snapshot_const(
-   const shoots_engine_t *engine,
--  char **out_snapshot,
--  size_t *out_length,
-+  shoots_provider_snapshot_t **out_snapshot,
-   shoots_error_info_t *out_error);
- 
--shoots_error_code_t shoots_engine_export_pending_provider_requests(
-+shoots_error_code_t shoots_engine_export_pending_provider_requests_const(
-   const shoots_engine_t *engine,
--  shoots_provider_request_t **out_requests,
-+  shoots_provider_request_record_t **out_list,
-   size_t *out_count,
-   shoots_error_info_t *out_error);
- 
--uint8_t shoots_engine_provider_ready(const shoots_engine_t *engine);
-+int shoots_engine_provider_ready(const shoots_engine_t *engine);
- 
- /* END BUILDER-ONLY FROZEN PROVIDER QUERIES */
- 
-diff --git a/tools/engine/src/execution_spine.h b/tools/engine/src/execution_spine.h
-index 3b4ee7e..d298e6f 100644
---- a/tools/engine/src/execution_spine.h
-+++ b/tools/engine/src/execution_spine.h
-@@ -3,20 +3,21 @@
- 
- #include "engine_internal.h"
- 
--/* BUILDER-ONLY FROZEN PROVIDER QUERIES (NO MUTATION) */
--shoots_error_code_t shoots_engine_export_provider_snapshot(
-+/* BUILDER-ONLY */
-+/* READ-ONLY */
-+/* FROZEN API  DO NOT EXTEND WITHOUT PHASE BUMP */
-+shoots_error_code_t shoots_engine_export_provider_snapshot_const(
-   const shoots_engine_t *engine,
--  char **out_snapshot,
--  size_t *out_length,
-+  shoots_provider_snapshot_t **out_snapshot,
-   shoots_error_info_t *out_error);
- 
--shoots_error_code_t shoots_engine_export_pending_provider_requests(
-+shoots_error_code_t shoots_engine_export_pending_provider_requests_const(
-   const shoots_engine_t *engine,
--  shoots_provider_request_t **out_requests,
-+  shoots_provider_request_record_t **out_list,
-   size_t *out_count,
-   shoots_error_info_t *out_error);
- 
--uint8_t shoots_engine_provider_ready(const shoots_engine_t *engine);
-+int shoots_engine_provider_ready(const shoots_engine_t *engine);
- 
- /* END BUILDER-ONLY FROZEN PROVIDER QUERIES */
- 
-diff --git a/tools/engine/src/provider_runtime.h b/tools/engine/src/provider_runtime.h
-index 6bc80df..f84c550 100644
---- a/tools/engine/src/provider_runtime.h
-+++ b/tools/engine/src/provider_runtime.h
-@@ -63,6 +63,11 @@ typedef struct shoots_provider_receipt {
-   uint8_t output_blob[SHOOTS_PROVIDER_OUTPUT_MAX_BYTES];
- } shoots_provider_receipt_t;
- 
-+typedef struct shoots_provider_snapshot {
-+  char   *payload;
-+  size_t  payload_len;
-+} shoots_provider_snapshot_t;
-+
- typedef struct shoots_provider_descriptor {
-   uint8_t provider_id_len;
-   char provider_id[SHOOTS_PROVIDER_ID_MAX];
-@@ -71,20 +76,21 @@ typedef struct shoots_provider_descriptor {
-   uint32_t guarantees_mask;
- } shoots_provider_descriptor_t;
- 
--/* BUILDER-ONLY FROZEN PROVIDER QUERIES (NO MUTATION) */
--shoots_error_code_t shoots_engine_export_provider_snapshot(
-+/* BUILDER-ONLY */
-+/* READ-ONLY */
-+/* FROZEN API  DO NOT EXTEND WITHOUT PHASE BUMP */
-+shoots_error_code_t shoots_engine_export_provider_snapshot_const(
-   const shoots_engine_t *engine,
--  char **out_snapshot,
--  size_t *out_length,
-+  shoots_provider_snapshot_t **out_snapshot,
-   shoots_error_info_t *out_error);
- 
--shoots_error_code_t shoots_engine_export_pending_provider_requests(
-+shoots_error_code_t shoots_engine_export_pending_provider_requests_const(
-   const shoots_engine_t *engine,
--  shoots_provider_request_t **out_requests,
-+  shoots_provider_request_record_t **out_list,
-   size_t *out_count,
-   shoots_error_info_t *out_error);
- 
--uint8_t shoots_engine_provider_ready(const shoots_engine_t *engine);
-+int shoots_engine_provider_ready(const shoots_engine_t *engine);
- 
- /* END BUILDER-ONLY FROZEN PROVIDER QUERIES */
- 
diff --git a/.ai/patches/patch-2026-01-30-18-52-09.diff b/.ai/patches/patch-2026-01-30-18-52-09.diff
deleted file mode 100644
index 28541b9..0000000
--- a/.ai/patches/patch-2026-01-30-18-52-09.diff
+++ /dev/null
@@ -1,70 +0,0 @@
-diff --git a/tools/engine/src/engine.c b/tools/engine/src/engine.c
-index fd13f2e..f95358b 100644
---- a/tools/engine/src/engine.c
-+++ b/tools/engine/src/engine.c
-@@ -3708,6 +3708,32 @@ shoots_error_code_t shoots_tool_invoke_internal(
-                      "ledger payload too large");
-     return SHOOTS_ERR_INVALID_ARGUMENT;
-   }
-+  char *payload = (char *)shoots_engine_alloc_internal(
-+      engine, payload_len + 1, out_error);
-+  if (payload == NULL) {
-+    return SHOOTS_ERR_OUT_OF_MEMORY;
-+  }
-+  int written = snprintf(payload, payload_len + 1,
-+                         "tool_invoke tool_id=%s status=REJECT reason=%s",
-+                         safe_tool_id, reason);
-+  if (written < 0) {
-+    shoots_engine_alloc_free_internal(engine, payload);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  shoots_ledger_entry_t *entry = NULL;
-+  shoots_error_code_t status = shoots_ledger_append_internal(
-+      engine, SHOOTS_LEDGER_ENTRY_ERROR, payload, &entry, out_error);
-+  shoots_engine_alloc_free_internal(engine, payload);
-+  if (status != SHOOTS_OK) {
-+    return status;
-+  }
-+  shoots_error_set(out_error, SHOOTS_ERR_UNSUPPORTED, SHOOTS_SEVERITY_RECOVERABLE,
-+                   "tool invocation not implemented");
-+  return SHOOTS_ERR_UNSUPPORTED;
-+}
-+
- shoots_error_code_t shoots_provider_request_mint_internal(
-   shoots_engine_t *engine,
-   shoots_session_t *session,
-@@ -4449,32 +4475,6 @@ shoots_error_code_t shoots_provider_receipt_map_terminal_internal(
-   return SHOOTS_OK;
- }
- 
--  char *payload = (char *)shoots_engine_alloc_internal(
--      engine, payload_len + 1, out_error);
--  if (payload == NULL) {
--    return SHOOTS_ERR_OUT_OF_MEMORY;
--  }
--  int written = snprintf(payload, payload_len + 1,
--                         "tool_invoke tool_id=%s status=REJECT reason=%s",
--                         safe_tool_id, reason);
--  if (written < 0) {
--    shoots_engine_alloc_free_internal(engine, payload);
--    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
--                     "ledger format failed");
--    return SHOOTS_ERR_INVALID_STATE;
--  }
--  shoots_ledger_entry_t *entry = NULL;
--  shoots_error_code_t status = shoots_ledger_append_internal(
--      engine, SHOOTS_LEDGER_ENTRY_ERROR, payload, &entry, out_error);
--  shoots_engine_alloc_free_internal(engine, payload);
--  if (status != SHOOTS_OK) {
--    return status;
--  }
--  shoots_error_set(out_error, SHOOTS_ERR_UNSUPPORTED, SHOOTS_SEVERITY_RECOVERABLE,
--                   "tool invocation not implemented");
--  return SHOOTS_ERR_UNSUPPORTED;
--}
--
- shoots_error_code_t shoots_provider_receipt_import_internal(
-   shoots_engine_t *engine,
-   const shoots_provider_receipt_t *receipt,
diff --git a/.ai/patches/patch-2026-02-01-21-09-17.diff b/.ai/patches/patch-2026-02-01-21-09-17.diff
deleted file mode 100644
index 170061c..0000000
--- a/.ai/patches/patch-2026-02-01-21-09-17.diff
+++ /dev/null
@@ -1,12 +0,0 @@
-diff --git a/tools/engine/src/engine.c b/tools/engine/src/engine.c
-index f95358b..01d715b 100644
---- a/tools/engine/src/engine.c
-+++ b/tools/engine/src/engine.c
-@@ -29,6 +29,7 @@ typedef struct shoots_alloc_header {
-   struct shoots_alloc_header *next;
- } shoots_alloc_header_t;
- 
-+/* Helper prototypes kept before first use for MSVC strictness. */
- static shoots_session_t *shoots_find_session(shoots_engine_t *engine, uint64_t session_id);
- static int shoots_provider_request_record_compare(const void *left, const void *right);
- static int shoots_provider_result_compare(const void *left, const void *right);
