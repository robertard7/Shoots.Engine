diff --git a/.ai/patches/patch-2026-01-30-01-04-36.diff b/.ai/patches/patch-2026-01-30-01-04-36.diff
deleted file mode 100644
index ed48b41..0000000
--- a/.ai/patches/patch-2026-01-30-01-04-36.diff
+++ /dev/null
@@ -1,195 +0,0 @@
-diff --git a/tools/engine/src/engine_internal.h b/tools/engine/src/engine_internal.h
-index 113eb71..da07536 100644
---- a/tools/engine/src/engine_internal.h
-+++ b/tools/engine/src/engine_internal.h
-@@ -316,6 +316,11 @@ shoots_error_code_t shoots_provider_registry_lock_internal(
-   shoots_engine_t *engine,
-   shoots_error_info_t *out_error);
- 
-+shoots_error_code_t shoots_provider_unregister_internal(
-+  shoots_engine_t *engine,
-+  const char *provider_id,
-+  shoots_error_info_t *out_error);
-+
- shoots_error_code_t shoots_session_create_internal(
-   shoots_engine_t *engine,
-   const char *intent_id,
-diff --git a/tools/engine/src/provider_runtime.c b/tools/engine/src/provider_runtime.c
-index 2313a25..083c67c 100644
---- a/tools/engine/src/provider_runtime.c
-+++ b/tools/engine/src/provider_runtime.c
-@@ -84,6 +84,32 @@ static void shoots_provider_format_id(const shoots_provider_descriptor_t *descri
-   }
- }
- 
-+static void shoots_provider_format_id_value(const char *provider_id,
-+                                            char *buffer,
-+                                            size_t buffer_len) {
-+  if (buffer == NULL || buffer_len == 0) {
-+    return;
-+  }
-+  if (provider_id == NULL) {
-+    strncpy(buffer, "(null)", buffer_len);
-+    buffer[buffer_len - 1] = '\0';
-+    return;
-+  }
-+  size_t length = 0;
-+  for (; length + 1 < buffer_len && length < SHOOTS_PROVIDER_ID_MAX; length++) {
-+    char value = provider_id[length];
-+    if (value == '\0') {
-+      break;
-+    }
-+    buffer[length] = value;
-+  }
-+  buffer[length] = '\0';
-+  if (length == 0) {
-+    strncpy(buffer, "(empty)", buffer_len);
-+    buffer[buffer_len - 1] = '\0';
-+  }
-+}
-+
- static shoots_error_code_t shoots_provider_emit_register_entry(
-   shoots_engine_t *engine,
-   const char *provider_id,
-@@ -149,6 +175,71 @@ static shoots_error_code_t shoots_provider_emit_register_entry(
-   return status_code;
- }
- 
-+static shoots_error_code_t shoots_provider_emit_unregister_entry(
-+  shoots_engine_t *engine,
-+  const char *provider_id,
-+  const char *status,
-+  const char *reason,
-+  shoots_error_info_t *out_error) {
-+  const char *safe_provider_id = provider_id != NULL ? provider_id : "(null)";
-+  const char *safe_status = status != NULL ? status : "UNKNOWN";
-+  const char *safe_reason = reason != NULL ? reason : "";
-+  const char *reason_format = reason != NULL && reason[0] != '\0'
-+                                  ? " reason=%s"
-+                                  : "%s";
-+  int required = snprintf(NULL, 0,
-+                          "provider_unregister provider_id=%s status=%s",
-+                          safe_provider_id, safe_status);
-+  if (required < 0) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  int reason_required = snprintf(NULL, 0, reason_format, safe_reason);
-+  if (reason_required < 0) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  size_t payload_len = (size_t)required + (size_t)reason_required;
-+  if (payload_len > SHOOTS_LEDGER_MAX_BYTES) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger payload too large");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  char *payload = (char *)shoots_engine_alloc_internal(
-+      engine, payload_len + 1, out_error);
-+  if (payload == NULL) {
-+    return SHOOTS_ERR_OUT_OF_MEMORY;
-+  }
-+  int written = snprintf(payload, payload_len + 1,
-+                         "provider_unregister provider_id=%s status=%s",
-+                         safe_provider_id, safe_status);
-+  if (written < 0) {
-+    shoots_engine_alloc_free_internal(engine, payload);
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "ledger format failed");
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  if (reason_required > 0 && reason != NULL && reason[0] != '\0') {
-+    int reason_written = snprintf(payload + written,
-+                                  payload_len + 1 - (size_t)written,
-+                                  " reason=%s",
-+                                  safe_reason);
-+    if (reason_written < 0) {
-+      shoots_engine_alloc_free_internal(engine, payload);
-+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                       "ledger format failed");
-+      return SHOOTS_ERR_INVALID_STATE;
-+    }
-+  }
-+  shoots_ledger_entry_t *entry = NULL;
-+  shoots_error_code_t status_code = shoots_ledger_append_internal(
-+      engine, SHOOTS_LEDGER_ENTRY_DECISION, payload, &entry, out_error);
-+  shoots_engine_alloc_free_internal(engine, payload);
-+  return status_code;
-+}
-+
- static shoots_error_code_t shoots_provider_emit_lock_entry(
-   shoots_engine_t *engine,
-   const char *status,
-@@ -429,3 +520,69 @@ shoots_error_code_t shoots_provider_registry_lock_internal(
-   engine->providers_locked = 1;
-   return shoots_provider_emit_lock_entry(engine, "ACCEPT", out_error);
- }
-+
-+shoots_error_code_t shoots_provider_unregister_internal(
-+  shoots_engine_t *engine,
-+  const char *provider_id,
-+  shoots_error_info_t *out_error) {
-+  shoots_error_clear(out_error);
-+  if (engine == NULL) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "engine is null");
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  char provider_id_value[SHOOTS_PROVIDER_ID_MAX];
-+  shoots_provider_format_id_value(provider_id, provider_id_value,
-+                                  sizeof(provider_id_value));
-+  if (engine->providers_locked) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "provider registry locked");
-+    shoots_provider_emit_unregister_entry(engine, provider_id_value, "REJECT",
-+                                          "locked", NULL);
-+    return SHOOTS_ERR_INVALID_STATE;
-+  }
-+  if (provider_id == NULL) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "provider_id is null");
-+    shoots_provider_emit_unregister_entry(engine, provider_id_value, "REJECT",
-+                                          "invalid_provider_id", NULL);
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  size_t provider_id_len = strnlen(provider_id, SHOOTS_PROVIDER_ID_MAX);
-+  if (provider_id_len == 0 || provider_id_len >= SHOOTS_PROVIDER_ID_MAX) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "provider_id invalid");
-+    shoots_provider_emit_unregister_entry(engine, provider_id_value, "REJECT",
-+                                          "invalid_provider_id", NULL);
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  size_t match_index = engine->provider_count;
-+  for (size_t index = 0; index < engine->provider_count; index++) {
-+    const shoots_provider_descriptor_t *existing = &engine->providers[index];
-+    if (existing->provider_id_len == provider_id_len &&
-+        memcmp(existing->provider_id, provider_id, provider_id_len) == 0) {
-+      match_index = index;
-+      break;
-+    }
-+  }
-+  if (match_index == engine->provider_count) {
-+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
-+                     "provider not found");
-+    shoots_provider_emit_unregister_entry(engine, provider_id_value, "REJECT",
-+                                          "not_found", NULL);
-+    return SHOOTS_ERR_INVALID_ARGUMENT;
-+  }
-+  for (size_t index = match_index + 1; index < engine->provider_count; index++) {
-+    engine->providers[index - 1] = engine->providers[index];
-+  }
-+  engine->provider_count--;
-+  memset(&engine->providers[engine->provider_count], 0,
-+         sizeof(engine->providers[engine->provider_count]));
-+  shoots_error_code_t ledger_status =
-+      shoots_provider_emit_unregister_entry(engine, provider_id_value, "ACCEPT",
-+                                            NULL, out_error);
-+  if (ledger_status != SHOOTS_OK) {
-+    return ledger_status;
-+  }
-+  return SHOOTS_OK;
-+}
diff --git a/tools/engine/src/engine.c b/tools/engine/src/engine.c
index fd904d2..b9880f2 100644
--- a/tools/engine/src/engine.c
+++ b/tools/engine/src/engine.c
@@ -738,6 +738,126 @@ static const char *shoots_tool_reject_code_text(shoots_tool_reject_code_t code)
   }
 }
 
+static const shoots_plan_record_t *shoots_session_find_plan(
+  const shoots_session_t *session,
+  uint64_t plan_id) {
+  if (session == NULL) {
+    return NULL;
+  }
+  for (size_t index = 0; index < session->plan_count; index++) {
+    if (session->plans[index].plan_id == plan_id) {
+      return &session->plans[index];
+    }
+  }
+  return NULL;
+}
+
+static void shoots_provider_request_format_id(
+  const shoots_provider_descriptor_t *provider,
+  char *buffer,
+  size_t buffer_len) {
+  if (buffer == NULL || buffer_len == 0) {
+    return;
+  }
+  if (provider == NULL) {
+    strncpy(buffer, "(null)", buffer_len);
+    buffer[buffer_len - 1] = '\0';
+    return;
+  }
+  size_t length = 0;
+  for (; length + 1 < buffer_len && length < SHOOTS_PROVIDER_ID_MAX; length++) {
+    char value = provider->provider_id[length];
+    if (value == '\0') {
+      break;
+    }
+    buffer[length] = value;
+  }
+  buffer[length] = '\0';
+  if (length == 0) {
+    strncpy(buffer, "(empty)", buffer_len);
+    buffer[buffer_len - 1] = '\0';
+  }
+}
+
+static shoots_error_code_t shoots_provider_request_append_decision(
+  shoots_engine_t *engine,
+  const char *provider_id,
+  const char *tool_id,
+  uint64_t plan_id,
+  uint64_t execution_slot,
+  uint64_t capability_mask,
+  uint64_t input_hash,
+  const char *status,
+  const char *reason,
+  shoots_error_info_t *out_error) {
+  const char *safe_provider_id = provider_id != NULL ? provider_id : "(null)";
+  const char *safe_tool_id = tool_id != NULL ? tool_id : "(null)";
+  const char *safe_status = status != NULL ? status : "UNKNOWN";
+  const char *safe_reason = reason != NULL ? reason : "";
+  const char *reason_format = reason != NULL && reason[0] != '\0'
+                                  ? " reason=%s"
+                                  : "%s";
+  int required = snprintf(NULL, 0,
+                          "provider_request status=%s provider_id=%s tool_id=%s"
+                          " plan_id=%" PRIu64 " execution_slot=%" PRIu64
+                          " capability_mask=0x%016" PRIx64
+                          " input_hash=0x%016" PRIx64,
+                          safe_status, safe_provider_id, safe_tool_id,
+                          plan_id, execution_slot, capability_mask, input_hash);
+  if (required < 0) {
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                     "ledger format failed");
+    return SHOOTS_ERR_INVALID_STATE;
+  }
+  int reason_required = snprintf(NULL, 0, reason_format, safe_reason);
+  if (reason_required < 0) {
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                     "ledger format failed");
+    return SHOOTS_ERR_INVALID_STATE;
+  }
+  size_t payload_len = (size_t)required + (size_t)reason_required;
+  if (payload_len > SHOOTS_LEDGER_MAX_BYTES) {
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
+                     "ledger payload too large");
+    return SHOOTS_ERR_INVALID_ARGUMENT;
+  }
+  char *payload = (char *)shoots_engine_alloc_internal(
+      engine, payload_len + 1, out_error);
+  if (payload == NULL) {
+    return SHOOTS_ERR_OUT_OF_MEMORY;
+  }
+  int written = snprintf(payload, payload_len + 1,
+                         "provider_request status=%s provider_id=%s tool_id=%s"
+                         " plan_id=%" PRIu64 " execution_slot=%" PRIu64
+                         " capability_mask=0x%016" PRIx64
+                         " input_hash=0x%016" PRIx64,
+                         safe_status, safe_provider_id, safe_tool_id,
+                         plan_id, execution_slot, capability_mask, input_hash);
+  if (written < 0) {
+    shoots_engine_alloc_free_internal(engine, payload);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                     "ledger format failed");
+    return SHOOTS_ERR_INVALID_STATE;
+  }
+  if (reason_required > 0 && reason != NULL && reason[0] != '\0') {
+    int reason_written = snprintf(payload + written,
+                                  payload_len + 1 - (size_t)written,
+                                  " reason=%s",
+                                  safe_reason);
+    if (reason_written < 0) {
+      shoots_engine_alloc_free_internal(engine, payload);
+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                       "ledger format failed");
+      return SHOOTS_ERR_INVALID_STATE;
+    }
+  }
+  shoots_ledger_entry_t *entry = NULL;
+  shoots_error_code_t status_code = shoots_ledger_append_internal(
+      engine, SHOOTS_LEDGER_ENTRY_DECISION, payload, &entry, out_error);
+  shoots_engine_alloc_free_internal(engine, payload);
+  return status_code;
+}
+
 static void shoots_tool_reject_reason_set(shoots_tool_reject_reason_t *reason,
                                           shoots_tool_reject_code_t code,
                                           const char *token) {
@@ -2549,6 +2669,273 @@ shoots_error_code_t shoots_tool_invoke_internal(
   return SHOOTS_ERR_UNSUPPORTED;
 }
 
+shoots_error_code_t shoots_provider_request_mint_internal(
+  shoots_engine_t *engine,
+  shoots_session_t *session,
+  uint64_t plan_id,
+  uint64_t execution_slot,
+  const char *tool_id,
+  const shoots_provider_descriptor_t *provider,
+  uint64_t capability_mask,
+  uint64_t input_hash,
+  const uint8_t *arg_blob,
+  uint32_t arg_size,
+  shoots_provider_request_t *out_request,
+  shoots_error_info_t *out_error) {
+  shoots_error_clear(out_error);
+  if (out_request == NULL) {
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
+                     "out_request is null");
+    return SHOOTS_ERR_INVALID_ARGUMENT;
+  }
+  memset(out_request, 0, sizeof(*out_request));
+  shoots_error_code_t engine_status = shoots_validate_engine(engine, out_error);
+  if (engine_status != SHOOTS_OK) {
+    return engine_status;
+  }
+  shoots_error_code_t session_status = shoots_validate_session(engine, session, out_error);
+  if (session_status != SHOOTS_OK) {
+    return session_status;
+  }
+  char provider_id_value[SHOOTS_PROVIDER_ID_MAX];
+  shoots_provider_request_format_id(provider, provider_id_value,
+                                    sizeof(provider_id_value));
+  if (session->state != SHOOTS_SESSION_STATE_ACTIVE) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "session_inactive", NULL);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                     "session not active");
+    return SHOOTS_ERR_INVALID_STATE;
+  }
+  if (plan_id == 0) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "plan_id_invalid", NULL);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
+                     "plan_id invalid");
+    return SHOOTS_ERR_INVALID_ARGUMENT;
+  }
+  if (!shoots_intent_exists(engine, session->intent_id)) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "intent_missing", NULL);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                     "intent missing");
+    return SHOOTS_ERR_INVALID_STATE;
+  }
+  if (shoots_session_find_plan(session, plan_id) == NULL) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "plan_not_found", NULL);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
+                     "plan not found");
+    return SHOOTS_ERR_INVALID_ARGUMENT;
+  }
+  if (tool_id == NULL || tool_id[0] == '\0') {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "tool_id_invalid", NULL);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
+                     "tool_id is null or empty");
+    return SHOOTS_ERR_INVALID_ARGUMENT;
+  }
+  size_t tool_id_len = strlen(tool_id);
+  if (tool_id_len >= SHOOTS_PROVIDER_TOOL_ID_MAX) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "tool_id_too_long", NULL);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
+                     "tool_id too long");
+    return SHOOTS_ERR_INVALID_ARGUMENT;
+  }
+  if (provider == NULL) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "provider_missing", NULL);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
+                     "provider is null");
+    return SHOOTS_ERR_INVALID_ARGUMENT;
+  }
+  shoots_error_code_t provider_status =
+      shoots_provider_descriptor_validate(provider, out_error);
+  if (provider_status != SHOOTS_OK) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "provider_invalid", NULL);
+    return provider_status;
+  }
+  const shoots_tool_record_t *tool = shoots_tool_find(engine, tool_id);
+  if (tool == NULL) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "tool_not_found", NULL);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
+                     "tool not found");
+    return SHOOTS_ERR_INVALID_ARGUMENT;
+  }
+  const shoots_provider_descriptor_t *registered_provider = NULL;
+  for (size_t index = 0; index < engine->provider_count; index++) {
+    const shoots_provider_descriptor_t *candidate = &engine->providers[index];
+    if (candidate->provider_id_len == provider->provider_id_len &&
+        memcmp(candidate->provider_id, provider->provider_id,
+               provider->provider_id_len) == 0) {
+      registered_provider = candidate;
+      break;
+    }
+  }
+  if (registered_provider == NULL) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "provider_not_registered", NULL);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
+                     "provider not registered");
+    return SHOOTS_ERR_INVALID_ARGUMENT;
+  }
+  uint32_t required_category = 0;
+  if (tool->category == SHOOTS_TOOL_CATEGORY_EXECUTION) {
+    required_category = SHOOTS_PROVIDER_TOOL_CATEGORY_EXECUTION;
+  } else if (tool->category == SHOOTS_TOOL_CATEGORY_INTEGRATION) {
+    required_category = SHOOTS_PROVIDER_TOOL_CATEGORY_INTEGRATION;
+  } else {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "tool_category_invalid", NULL);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
+                     "tool category invalid");
+    return SHOOTS_ERR_INVALID_ARGUMENT;
+  }
+  if ((registered_provider->supported_tool_categories & required_category) == 0) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "category_mismatch", NULL);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
+                     "provider category mismatch");
+    return SHOOTS_ERR_INVALID_ARGUMENT;
+  }
+  if ((tool->determinism_flags & ~registered_provider->guarantees_mask) != 0) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "guarantee_mismatch", NULL);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
+                     "provider guarantees mismatch");
+    return SHOOTS_ERR_INVALID_ARGUMENT;
+  }
+  if ((capability_mask & ~tool->capabilities) != 0) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "capability_mismatch", NULL);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
+                     "capability mask invalid");
+    return SHOOTS_ERR_INVALID_ARGUMENT;
+  }
+  if (arg_size > SHOOTS_PROVIDER_ARG_MAX_BYTES) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "arg_too_large", NULL);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
+                     "arg size too large");
+    return SHOOTS_ERR_INVALID_ARGUMENT;
+  }
+  if (arg_size > 0 && arg_blob == NULL) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "arg_missing", NULL);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
+                     "arg blob missing");
+    return SHOOTS_ERR_INVALID_ARGUMENT;
+  }
+  if (execution_slot == 0) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "execution_slot_invalid", NULL);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
+                     "execution_slot invalid");
+    return SHOOTS_ERR_INVALID_ARGUMENT;
+  }
+  if (session->has_active_execution) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "execution_active", NULL);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                     "execution already active");
+    return SHOOTS_ERR_INVALID_STATE;
+  }
+  if (session->has_terminal_execution &&
+      execution_slot <= session->terminal_execution_slot) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "execution_slot_terminal", NULL);
+    return shoots_invariant_violation(engine, "execution slot terminal", out_error);
+  }
+  if (session->next_execution_slot == 0) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "execution_slots_exhausted", NULL);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                     "execution slots exhausted");
+    return SHOOTS_ERR_INVALID_STATE;
+  }
+  if (execution_slot != session->next_execution_slot) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "execution_slot_out_of_order", NULL);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
+                     "execution slot out of order");
+    return SHOOTS_ERR_INVALID_ARGUMENT;
+  }
+  shoots_error_code_t runtime_status =
+      shoots_provider_runtime_validate_ready(engine->provider_runtime, out_error);
+  if (runtime_status != SHOOTS_OK) {
+    shoots_provider_request_append_decision(
+        engine, provider_id_value, tool_id, plan_id, execution_slot,
+        capability_mask, input_hash, "REJECT", "runtime_invalid", NULL);
+    return runtime_status;
+  }
+
+  out_request->session_id = session->session_id;
+  out_request->plan_id = plan_id;
+  out_request->execution_slot = execution_slot;
+  out_request->provider_id_len = provider->provider_id_len;
+  memcpy(out_request->provider_id, provider->provider_id, provider->provider_id_len);
+  out_request->provider_id[provider->provider_id_len] = '\0';
+  out_request->tool_id_len = (uint8_t)tool_id_len;
+  memcpy(out_request->tool_id, tool_id, tool_id_len + 1);
+  out_request->tool_version = tool->version;
+  out_request->capability_mask = capability_mask;
+  out_request->input_hash = input_hash;
+  out_request->arg_size = arg_size;
+  if (arg_size > 0) {
+    memcpy(out_request->arg_blob, arg_blob, arg_size);
+  }
+
+  uint64_t previous_next_slot = session->next_execution_slot;
+  shoots_error_code_t transition_status =
+      shoots_session_transition_active_internal(session, execution_slot, out_error);
+  if (transition_status != SHOOTS_OK) {
+    return shoots_invariant_violation(engine, "execution slot transition failed",
+                                      out_error);
+  }
+  if (session->next_execution_slot == UINT64_MAX) {
+    session->next_execution_slot = 0;
+  } else {
+    session->next_execution_slot++;
+  }
+
+  shoots_error_code_t ledger_status =
+      shoots_provider_request_append_decision(
+          engine, provider_id_value, tool_id, plan_id, execution_slot,
+          capability_mask, input_hash, "ACCEPT", NULL, out_error);
+  if (ledger_status != SHOOTS_OK) {
+    session->has_active_execution = 0;
+    session->active_execution_slot = 0;
+    session->next_execution_slot = previous_next_slot;
+    return ledger_status;
+  }
+  shoots_assert_invariants(engine);
+  return SHOOTS_OK;
+}
+
 shoots_error_code_t shoots_plan_internal(
   shoots_engine_t *engine,
   const shoots_plan_request_t *request,
diff --git a/tools/engine/src/engine_internal.h b/tools/engine/src/engine_internal.h
index da07536..f00a718 100644
--- a/tools/engine/src/engine_internal.h
+++ b/tools/engine/src/engine_internal.h
@@ -321,6 +321,20 @@ shoots_error_code_t shoots_provider_unregister_internal(
   const char *provider_id,
   shoots_error_info_t *out_error);
 
+shoots_error_code_t shoots_provider_request_mint_internal(
+  shoots_engine_t *engine,
+  shoots_session_t *session,
+  uint64_t plan_id,
+  uint64_t execution_slot,
+  const char *tool_id,
+  const shoots_provider_descriptor_t *provider,
+  uint64_t capability_mask,
+  uint64_t input_hash,
+  const uint8_t *arg_blob,
+  uint32_t arg_size,
+  shoots_provider_request_t *out_request,
+  shoots_error_info_t *out_error);
+
 shoots_error_code_t shoots_session_create_internal(
   shoots_engine_t *engine,
   const char *intent_id,
diff --git a/tools/engine/src/execution_spine.c b/tools/engine/src/execution_spine.c
index 2a1ed34..560ce7d 100644
--- a/tools/engine/src/execution_spine.c
+++ b/tools/engine/src/execution_spine.c
@@ -20,3 +20,21 @@ shoots_error_code_t spine_record_result(
   return shoots_result_append_internal(engine, session, command_id,
                                        status, payload, out_record, out_error);
 }
+
+shoots_error_code_t spine_mint_provider_request(
+  shoots_engine_t *engine,
+  shoots_session_t *session,
+  uint64_t plan_id,
+  uint64_t execution_slot,
+  const char *tool_id,
+  const shoots_provider_descriptor_t *provider,
+  uint64_t capability_mask,
+  uint64_t input_hash,
+  const uint8_t *arg_blob,
+  uint32_t arg_size,
+  shoots_provider_request_t *out_request,
+  shoots_error_info_t *out_error) {
+  return shoots_provider_request_mint_internal(
+      engine, session, plan_id, execution_slot, tool_id, provider,
+      capability_mask, input_hash, arg_blob, arg_size, out_request, out_error);
+}
diff --git a/tools/engine/src/execution_spine.h b/tools/engine/src/execution_spine.h
index 0b1b1fe..7414405 100644
--- a/tools/engine/src/execution_spine.h
+++ b/tools/engine/src/execution_spine.h
@@ -19,4 +19,18 @@ shoots_error_code_t spine_record_result(
   shoots_result_record_t **out_record,
   shoots_error_info_t *out_error);
 
+shoots_error_code_t spine_mint_provider_request(
+  shoots_engine_t *engine,
+  shoots_session_t *session,
+  uint64_t plan_id,
+  uint64_t execution_slot,
+  const char *tool_id,
+  const shoots_provider_descriptor_t *provider,
+  uint64_t capability_mask,
+  uint64_t input_hash,
+  const uint8_t *arg_blob,
+  uint32_t arg_size,
+  shoots_provider_request_t *out_request,
+  shoots_error_info_t *out_error);
+
 #endif
diff --git a/tools/engine/src/provider_runtime.h b/tools/engine/src/provider_runtime.h
index 51b3834..386dc64 100644
--- a/tools/engine/src/provider_runtime.h
+++ b/tools/engine/src/provider_runtime.h
@@ -35,9 +35,12 @@ typedef struct shoots_provider_request {
   uint64_t session_id;
   uint64_t plan_id;
   uint64_t execution_slot;
+  uint8_t provider_id_len;
+  char provider_id[SHOOTS_PROVIDER_ID_MAX];
   uint8_t tool_id_len;
   char tool_id[SHOOTS_PROVIDER_TOOL_ID_MAX];
   uint32_t tool_version;
+  uint64_t capability_mask;
   uint64_t input_hash;
   uint32_t arg_size;
   uint8_t arg_blob[SHOOTS_PROVIDER_ARG_MAX_BYTES];
