diff --git a/tools/engine/src/engine.c b/tools/engine/src/engine.c
index 547f0da..ad85038 100644
--- a/tools/engine/src/engine.c
+++ b/tools/engine/src/engine.c
@@ -187,6 +187,8 @@ static void shoots_assert_invariants(const shoots_engine_t *engine) {
     }
   }
   assert(engine->tools_locked <= 1);
+  assert(engine->provider_count <= SHOOTS_ENGINE_MAX_PROVIDERS);
+  assert(engine->providers_locked <= 1);
   if (engine->results_head == NULL) {
     assert(engine->results_tail == NULL);
   } else {
@@ -1306,6 +1308,8 @@ shoots_error_code_t shoots_engine_create(const shoots_config_t *config,
   engine->magic = SHOOTS_ENGINE_MAGIC;
   engine->allocations_head = NULL;
   engine->provider_runtime = NULL;
+  engine->provider_count = 0;
+  engine->providers_locked = 0;
   engine->models_head = NULL;
   engine->models_tail = NULL;
   engine->sessions_head = NULL;
@@ -1351,6 +1355,7 @@ shoots_error_code_t shoots_engine_create(const shoots_config_t *config,
     return runtime_status;
   }
 
+  engine->providers_locked = 1;
   engine->tools_locked = 1;
 
   *out_engine = engine;
@@ -1410,6 +1415,8 @@ shoots_error_code_t shoots_engine_destroy(shoots_engine_t *engine,
   engine->tools_head = NULL;
   engine->tools_tail = NULL;
   engine->tools_locked = 0;
+  engine->provider_count = 0;
+  engine->providers_locked = 0;
   engine->results_head = NULL;
   engine->results_tail = NULL;
   engine->commands_head = NULL;
diff --git a/tools/engine/src/engine_internal.h b/tools/engine/src/engine_internal.h
index a06cb09..32de924 100644
--- a/tools/engine/src/engine_internal.h
+++ b/tools/engine/src/engine_internal.h
@@ -178,6 +178,7 @@ typedef struct shoots_result_record {
 
 #define SHOOTS_SESSION_MAX_PLANS 4u
 #define SHOOTS_SESSION_PLAN_MAX_TOOLS 64u
+#define SHOOTS_ENGINE_MAX_PROVIDERS 8u
 
 typedef struct shoots_plan_record {
   uint64_t plan_id;
@@ -255,6 +256,9 @@ struct shoots_engine {
   void   *allocations_head;
 
   shoots_provider_runtime_t *provider_runtime;
+  shoots_provider_descriptor_t providers[SHOOTS_ENGINE_MAX_PROVIDERS];
+  size_t provider_count;
+  uint8_t providers_locked;
 
   struct shoots_model   *models_head;
   struct shoots_model   *models_tail;
@@ -303,6 +307,11 @@ void shoots_engine_alloc_free_internal(
   shoots_engine_t *engine,
   void *buffer);
 
+shoots_error_code_t shoots_provider_register_internal(
+  shoots_engine_t *engine,
+  const shoots_provider_descriptor_t *descriptor,
+  shoots_error_info_t *out_error);
+
 shoots_error_code_t shoots_session_create_internal(
   shoots_engine_t *engine,
   const char *intent_id,
diff --git a/tools/engine/src/provider_runtime.c b/tools/engine/src/provider_runtime.c
index e19b1ed..02a5f82 100644
--- a/tools/engine/src/provider_runtime.c
+++ b/tools/engine/src/provider_runtime.c
@@ -1,5 +1,6 @@
 #include "engine_internal.h"
 
+#include <stdio.h>
 #include <string.h>
 #ifndef NDEBUG
 #include <assert.h>
@@ -57,6 +58,97 @@ static void shoots_error_set(shoots_error_info_t *out_error,
   out_error->message = message;
 }
 
+static void shoots_provider_format_id(const shoots_provider_descriptor_t *descriptor,
+                                      char *buffer,
+                                      size_t buffer_len) {
+  if (buffer == NULL || buffer_len == 0) {
+    return;
+  }
+  if (descriptor == NULL) {
+    strncpy(buffer, "(null)", buffer_len);
+    buffer[buffer_len - 1] = '\0';
+    return;
+  }
+  size_t length = 0;
+  for (; length + 1 < buffer_len && length < SHOOTS_PROVIDER_ID_MAX; length++) {
+    char value = descriptor->provider_id[length];
+    if (value == '\0') {
+      break;
+    }
+    buffer[length] = value;
+  }
+  buffer[length] = '\0';
+  if (length == 0) {
+    strncpy(buffer, "(empty)", buffer_len);
+    buffer[buffer_len - 1] = '\0';
+  }
+}
+
+static shoots_error_code_t shoots_provider_emit_register_entry(
+  shoots_engine_t *engine,
+  const char *provider_id,
+  const char *status,
+  const char *reason,
+  shoots_error_info_t *out_error) {
+  const char *safe_provider_id = provider_id != NULL ? provider_id : "(null)";
+  const char *safe_status = status != NULL ? status : "UNKNOWN";
+  const char *safe_reason = reason != NULL ? reason : "";
+  const char *reason_format = reason != NULL && reason[0] != '\0'
+                                  ? " reason=%s"
+                                  : "%s";
+  int required = snprintf(NULL, 0,
+                          "provider_register provider_id=%s status=%s",
+                          safe_provider_id, safe_status);
+  if (required < 0) {
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                     "ledger format failed");
+    return SHOOTS_ERR_INVALID_STATE;
+  }
+  int reason_required = snprintf(NULL, 0, reason_format, safe_reason);
+  if (reason_required < 0) {
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                     "ledger format failed");
+    return SHOOTS_ERR_INVALID_STATE;
+  }
+  size_t payload_len = (size_t)required + (size_t)reason_required;
+  if (payload_len > SHOOTS_LEDGER_MAX_BYTES) {
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
+                     "ledger payload too large");
+    return SHOOTS_ERR_INVALID_ARGUMENT;
+  }
+  char *payload = (char *)shoots_engine_alloc_internal(
+      engine, payload_len + 1, out_error);
+  if (payload == NULL) {
+    return SHOOTS_ERR_OUT_OF_MEMORY;
+  }
+  int written = snprintf(payload, payload_len + 1,
+                         "provider_register provider_id=%s status=%s",
+                         safe_provider_id, safe_status);
+  if (written < 0) {
+    shoots_engine_alloc_free_internal(engine, payload);
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                     "ledger format failed");
+    return SHOOTS_ERR_INVALID_STATE;
+  }
+  if (reason_required > 0 && reason != NULL && reason[0] != '\0') {
+    int reason_written = snprintf(payload + written,
+                                  payload_len + 1 - (size_t)written,
+                                  " reason=%s",
+                                  safe_reason);
+    if (reason_written < 0) {
+      shoots_engine_alloc_free_internal(engine, payload);
+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                       "ledger format failed");
+      return SHOOTS_ERR_INVALID_STATE;
+    }
+  }
+  shoots_ledger_entry_t *entry = NULL;
+  shoots_error_code_t status_code = shoots_ledger_append_internal(
+      engine, SHOOTS_LEDGER_ENTRY_DECISION, payload, &entry, out_error);
+  shoots_engine_alloc_free_internal(engine, payload);
+  return status_code;
+}
+
 shoots_error_code_t shoots_provider_runtime_create(
   shoots_engine_t *engine,
   const shoots_config_t *config,
@@ -223,3 +315,58 @@ shoots_error_code_t shoots_provider_descriptor_validate(
   }
   return SHOOTS_OK;
 }
+
+shoots_error_code_t shoots_provider_register_internal(
+  shoots_engine_t *engine,
+  const shoots_provider_descriptor_t *descriptor,
+  shoots_error_info_t *out_error) {
+  shoots_error_clear(out_error);
+  if (engine == NULL) {
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT, SHOOTS_SEVERITY_RECOVERABLE,
+                     "engine is null");
+    return SHOOTS_ERR_INVALID_ARGUMENT;
+  }
+  char provider_id[SHOOTS_PROVIDER_ID_MAX];
+  shoots_provider_format_id(descriptor, provider_id, sizeof(provider_id));
+  shoots_error_code_t validation_status =
+      shoots_provider_descriptor_validate(descriptor, out_error);
+  if (validation_status != SHOOTS_OK) {
+    shoots_provider_emit_register_entry(engine, provider_id, "REJECT",
+                                        "invalid_descriptor", NULL);
+    return validation_status;
+  }
+  if (engine->providers_locked) {
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                     "provider registry locked");
+    shoots_provider_emit_register_entry(engine, provider_id, "REJECT", "locked", NULL);
+    return SHOOTS_ERR_INVALID_STATE;
+  }
+  if (engine->provider_count >= SHOOTS_ENGINE_MAX_PROVIDERS) {
+    shoots_error_set(out_error, SHOOTS_ERR_INVALID_STATE, SHOOTS_SEVERITY_RECOVERABLE,
+                     "provider registry full");
+    shoots_provider_emit_register_entry(engine, provider_id, "REJECT",
+                                        "registry_full", NULL);
+    return SHOOTS_ERR_INVALID_STATE;
+  }
+  for (size_t index = 0; index < engine->provider_count; index++) {
+    const shoots_provider_descriptor_t *existing = &engine->providers[index];
+    if (existing->provider_id_len == descriptor->provider_id_len &&
+        memcmp(existing->provider_id, descriptor->provider_id,
+               descriptor->provider_id_len) == 0) {
+      shoots_error_set(out_error, SHOOTS_ERR_INVALID_ARGUMENT,
+                       SHOOTS_SEVERITY_RECOVERABLE, "provider_id exists");
+      shoots_provider_emit_register_entry(engine, provider_id, "REJECT",
+                                          "provider_exists", NULL);
+      return SHOOTS_ERR_INVALID_ARGUMENT;
+    }
+  }
+  engine->providers[engine->provider_count] = *descriptor;
+  engine->provider_count++;
+  shoots_error_code_t ledger_status =
+      shoots_provider_emit_register_entry(engine, provider_id, "ACCEPT", NULL,
+                                          out_error);
+  if (ledger_status != SHOOTS_OK) {
+    return ledger_status;
+  }
+  return SHOOTS_OK;
+}
